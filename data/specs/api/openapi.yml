components:
  responses: {}
  schemas:
    ListUsersResponse:
      description: A paginated list of users.
      example:
        entries:
          - __typename: User
            created_at: null
            email: jane@ingen.net
            id: jane
            name: Jane Doe
            updated_at: '2024-05-22T12:00:00Z'
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of users.
          items:
            $ref: '#/components/schemas/User'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      title: ListUsersResponse
      type: object
    ChannelData:
      description: Channel data for a given channel type.
      example:
        __typename: ChannelData
        channel_id: 123e4567-e89b-12d3-a456-426614174000
        data:
          __typename: PushChannelData
          tokens:
            - push_token_1
      properties:
        __typename:
          description: The typename of the schema.
          example: ChannelData
          type: string
        channel_id:
          description: The unique identifier for the channel.
          format: uuid
          type: string
        data:
          description: Channel data for a given channel type.
          discriminator:
            mapping:
              DiscordChannelData: '#/components/schemas/DiscordChannelData'
              MsTeamsChannelData: '#/components/schemas/MsTeamsChannelData'
              OneSignalChannelData: '#/components/schemas/OneSignalChannelData'
              PushChannelData: '#/components/schemas/PushChannelData'
              SlackChannelData: '#/components/schemas/SlackChannelData'
            propertyName: __typename
          oneOf:
            - $ref: '#/components/schemas/PushChannelData'
            - $ref: '#/components/schemas/SlackChannelData'
            - $ref: '#/components/schemas/MsTeamsChannelData'
            - $ref: '#/components/schemas/DiscordChannelData'
            - $ref: '#/components/schemas/OneSignalChannelData'
          type: object
      required:
        - __typename
        - channel_id
        - data
      title: ChannelData
      type: object
    AddAudienceMembersRequest:
      description: A request to add a list of audience members.
      example:
        members:
          - tenant: null
            user:
              email: jane@ingen.net
              id: user_1
              name: Jane Doe
              timezone: America/New_York
      properties:
        members:
          description: A list of audience members to add.
          items:
            $ref: '#/components/schemas/AudienceMemberRequest'
          nullable: false
          type: array
      required:
        - members
      title: AddAudienceMembersRequest
      type: object
    TriggerWorkflowResponse:
      description: The response from triggering a workflow
      example:
        workflow_run_id: 123e4567-e89b-12d3-a456-426614174000
      properties:
        workflow_run_id:
          description: >-
            The ID of the workflow trigger. This value allows you to track individual workflow runs associated
            with this trigger request.
          example: 123e4567-e89b-12d3-a456-426614174000
          format: uuid
          type: string
      required:
        - workflow_run_id
      title: TriggerWorkflowResponse
      type: object
    Subscription:
      description: A subscription object.
      example:
        __typename: Subscription
        inserted_at: '2021-01-01T00:00:00Z'
        object:
          __typename: Object
          collection: projects
          created_at: null
          id: project_1
          name: My first project
          updated_at: '2024-05-22T12:00:00Z'
        recipient:
          __typename: User
          avatar: null
          created_at: null
          email: jane@ingen.net
          id: jane
          name: Jane Doe
          phone_number: null
          timezone: null
          updated_at: '2024-05-22T12:00:00Z'
        updated_at: '2021-01-01T00:00:00Z'
      properties:
        __typename:
          description: The typename of the schema.
          example: Subscription
          type: string
        inserted_at:
          description: Timestamp when the resource was created.
          example: '2021-01-01T00:00:00Z'
          format: date-time
          type: string
        object:
          $ref: '#/components/schemas/Object'
        properties:
          additionalProperties: true
          description: The custom properties associated with the recipients of the subscription.
          nullable: true
          type: object
        recipient:
          $ref: '#/components/schemas/Recipient'
        updated_at:
          description: The timestamp when the resource was last updated.
          example: '2021-01-01T00:00:00Z'
          format: date-time
          type: string
      required:
        - __typename
        - recipient
        - object
        - inserted_at
        - updated_at
      title: Subscription
      type: object
    ListUserPreferenceSetsResponse:
      description: A list of preference sets for the user.
      example:
        - __typename: PreferenceSet
          categories:
            marketing: false
            transactional:
              channel_types:
                email: false
          channel_types:
            email: true
            push: false
            sms:
              conditions:
                - argument: US
                  operator: equal_to
                  variable: recipient.country_code
          id: default
          workflows: null
      items:
        $ref: '#/components/schemas/PreferenceSet'
      title: ListUserPreferenceSetsResponse
      type: array
    PreferenceSetWorkflowCategorySettingObject:
      description: The settings object for a workflow or category, where you can specify channel types or conditions.
      example:
        channel_types:
          email: false
        conditions: null
      properties:
        channel_types:
          anyOf:
            - $ref: '#/components/schemas/PreferenceSetChannelTypes'
            - nullable: true
          description: A map of preference set channel types.
        conditions:
          description: A list of conditions to apply to a channel type.
          items:
            $ref: '#/components/schemas/Condition'
          nullable: true
          type: array
      title: PreferenceSetWorkflowCategorySettingObject
      type: object
    MsTeamsTokenConnection:
      description: Microsoft Teams token connection.
      example:
        ms_teams_channel_id: 123e4567-e89b-12d3-a456-426614174000
        ms_teams_team_id: 123e4567-e89b-12d3-a456-426614174000
        ms_teams_tenant_id: null
        ms_teams_user_id: null
      properties:
        ms_teams_channel_id:
          description: Microsoft Teams channel ID.
          format: uuid
          nullable: true
          type: string
        ms_teams_team_id:
          description: Microsoft Teams team ID.
          format: uuid
          nullable: true
          type: string
        ms_teams_tenant_id:
          description: Microsoft Teams tenant ID.
          format: uuid
          nullable: true
          type: string
        ms_teams_user_id:
          description: Microsoft Teams user ID.
          format: uuid
          nullable: true
          type: string
      title: MsTeamsTokenConnection
      type: object
    TriggerWorkflowRequest:
      description: A request to trigger a notification workflow.
      example:
        actor: null
        cancellation_key: null
        data:
          dinosaur_names:
            - Tyrannosaurus
            - Velociraptor
            - Stegosaurus
          is_alert: true
          park_id: prk_1
          severity: 1
          welcome_message: Welcome, to Jurassic Park!
        recipients:
          - jhammond
        tenant: acme_corp
      properties:
        actor:
          anyOf:
            - $ref: '#/components/schemas/RecipientRequest'
            - nullable: true
          description: >-
            A map of properties describing a user or an object to identify in Knock and mark as who or what
            performed the action.
        cancellation_key:
          description: >-
            The cancellation key provided during the initial notify call. If used in a cancel request, will
            cancel the notification for the recipients specified in the cancel request.
          nullable: true
          type: string
        data:
          additionalProperties: true
          description: An optional map of data to pass into the workflow execution.
          nullable: true
          type: object
        recipients:
          description: >-
            The recipients to trigger the workflow for. Can inline identify users, objects, or use a list of
            user ids. Cannot exceed 1000 recipients in a single trigger.
          items:
            $ref: '#/components/schemas/RecipientRequest'
          type: array
        tenant:
          anyOf:
            - $ref: '#/components/schemas/InlineTenantRequest'
            - nullable: true
          description: >-
            The tenant to trigger the workflow for. Triggering with a tenant will use any tenant-level
            overrides associated with the tenant object, and all messages produced from workflow runs will be
            tagged with the tenant.
      required:
        - recipients
      title: TriggerWorkflowRequest
      type: object
    BulkIdentifyUsersRequest:
      description: A request to identify a list of users.
      example:
        users:
          - email: jane@ingen.net
            id: user_1
            name: Jane Doe
            timezone: America/New_York
      properties:
        users:
          description: A list of users.
          items:
            $ref: '#/components/schemas/InlineIdentifyUserRequest'
          type: array
      required:
        - users
      title: BulkIdentifyUsersRequest
      type: object
    InlinePreferenceSetRequest:
      additionalProperties:
        $ref: '#/components/schemas/PreferenceSetRequest'
      description: Inline set preferences for a recipient, where the key is the preference set name
      example:
        default:
          categories:
            transactional:
              channel_types:
                email: false
          channel_types: null
          workflows:
            dinosaurs-loose:
              channel_types:
                email: true
      title: InlinePreferenceSetRequest
      type: object
    MessageContents:
      description: The content of a message.
      example:
        __typename: MessageContent
        data:
          __typename: MessageSmsContent
          body: Hello, world!
          to: user_123
        inserted_at: '2021-01-01T00:00:00Z'
        message_id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
      properties:
        __typename:
          description: The typename of the schema.
          example: MessageContent
          nullable: false
          type: string
        data:
          description: Content data specific to the channel type.
          nullable: false
          oneOf:
            - $ref: '#/components/schemas/MessageEmailContent'
            - $ref: '#/components/schemas/MessageSmsContent'
            - $ref: '#/components/schemas/MessagePushContent'
            - $ref: '#/components/schemas/MessageChatContent'
            - $ref: '#/components/schemas/MessageInAppFeedContent'
          type: object
        inserted_at:
          description: Timestamp when the message content was created.
          example: '2021-01-01T00:00:00Z'
          format: date-time
          nullable: false
          type: string
        message_id:
          description: The unique identifier for the message content.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          nullable: false
          type: string
      required:
        - __typename
        - message_id
        - data
        - inserted_at
      title: MessageContents
      type: object
    ListAudienceMembersResponse:
      description: A paginated list of audience members.
      example:
        entries:
          - __typename: AudienceMember
            added_at: '2021-01-01T00:00:00Z'
            tenant: acme_corp
            user:
              __typename: User
              created_at: null
              email: jane@ingen.net
              id: jane
              name: Jane Doe
              updated_at: '2024-05-22T12:00:00Z'
            user_id: user_123
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of audience members.
          items:
            $ref: '#/components/schemas/AudienceMember'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      required:
        - entries
        - page_info
      title: ListAudienceMembersResponse
      type: object
    InlineChannelDataRequest:
      additionalProperties:
        $ref: '#/components/schemas/ChannelDataRequest'
      description: A request to set channel data for a type of channel inline.
      example:
        97c5837d-c65c-4d54-aa39-080eeb81c69d:
          data:
            __typename: PushChannelData
            tokens:
              - push_token_xxx
      title: InlineChannelDataRequest
      type: object
    MessageEmailContent:
      description: The content of an email message.
      example:
        __typename: MessageEmailContent
        bcc: null
        cc: null
        from: noreply@example.com
        html_body: <p>Hello, world!</p>
        reply_to: null
        subject_line: Hello, world!
        text_body: Hello, world!
        to: user_123@example.com
      properties:
        __typename:
          description: The typename of the schema.
          example: MessageEmailContent
          nullable: false
          type: string
        bcc:
          description: The BCC email addresses.
          nullable: true
          type: string
        cc:
          description: The CC email addresses.
          nullable: true
          type: string
        from:
          description: The sender's email address.
          nullable: false
          type: string
        html_body:
          description: The HTML body of the email message.
          nullable: false
          type: string
        reply_to:
          description: The reply-to email address.
          nullable: true
          type: string
        subject_line:
          description: The subject line of the email message.
          nullable: false
          type: string
        text_body:
          description: The text body of the email message.
          nullable: false
          type: string
        to:
          description: The recipient's email address.
          nullable: false
          type: string
      required:
        - __typename
        - html_body
        - text_body
        - subject_line
        - from
        - to
      title: MessageEmailContent
      type: object
    Notify Response:
      description: The response from triggering a workflow
      example:
        result_id: wf_1234567890abcdef
      properties:
        result_id:
          description: >-
            The ID of the workflow trigger. This value allows you to track individual workflow runs associated
            with this trigger request.
          type: string
      required:
        - result_id
      title: Notify Response
      type: object
    InlineTenantRequest:
      description: An request to set a tenant inline.
      example:
        id: tenant_1
        name: Acme Corp, Inc.
      oneOf:
        - description: The unique identifier for the tenant.
          type: string
        - $ref: '#/components/schemas/TenantRequest'
      title: InlineTenantRequest
    PreferenceSetChannelTypes:
      description: Channel type preferences.
      example:
        email: true
        sms:
          conditions:
            - argument: US
              operator: equal_to
              variable: recipient.country_code
      properties:
        chat:
          description: Whether the channel type is enabled for the preference set.
          oneOf:
            - type: boolean
            - $ref: '#/components/schemas/PreferenceSetChannelTypeSetting'
        email:
          description: Whether the channel type is enabled for the preference set.
          oneOf:
            - type: boolean
            - $ref: '#/components/schemas/PreferenceSetChannelTypeSetting'
        http:
          description: Whether the channel type is enabled for the preference set.
          oneOf:
            - type: boolean
            - $ref: '#/components/schemas/PreferenceSetChannelTypeSetting'
        in_app_feed:
          description: Whether the channel type is enabled for the preference set.
          oneOf:
            - type: boolean
            - $ref: '#/components/schemas/PreferenceSetChannelTypeSetting'
        push:
          description: Whether the channel type is enabled for the preference set.
          oneOf:
            - type: boolean
            - $ref: '#/components/schemas/PreferenceSetChannelTypeSetting'
        sms:
          description: Whether the channel type is enabled for the preference set.
          oneOf:
            - type: boolean
            - $ref: '#/components/schemas/PreferenceSetChannelTypeSetting'
      title: PreferenceSetChannelTypes
      type: object
    MessageEvent:
      description: A message event.
      example:
        __typename: MessageEvent
        data: null
        id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
        inserted_at: '2021-01-01T00:00:00Z'
        recipient: user_123
        type: message.sent
      properties:
        __typename:
          description: The typename of the schema.
          example: MessageEvent
          type: string
        data:
          additionalProperties: true
          description: The data associated with the message event. Only present for some event types.
          nullable: true
          type: object
        id:
          description: The unique identifier for the message event.
          example: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
          type: string
        inserted_at:
          description: Timestamp when the event was created.
          example: '2021-01-01T00:00:00Z'
          format: date-time
          type: string
        recipient:
          $ref: '#/components/schemas/RecipientReference'
        type:
          description: The type of event that occurred.
          enum:
            - message.archived
            - message.bounced
            - message.delivered
            - message.delivery_attempted
            - message.interacted
            - message.link_clicked
            - message.not_sent
            - message.queued
            - message.read
            - message.seen
            - message.sent
            - message.unarchived
            - message.undelivered
            - message.unread
            - message.unseen
          example: message.sent
          type: string
      required:
        - __typename
        - id
        - inserted_at
        - recipient
        - type
      title: MessageEvent
      type: object
    GuideActionRequest:
      description: A request to trigger a guide action.
      example:
        channel_id: 123e4567-e89b-12d3-a456-426614174000
        content: content_12345
        data: data_12345
        guide_id: 323e4567-e89b-12d3-a456-426614174000
        guide_key: guide_12345
        guide_step_ref: step_12345
        is_final: true
        metadata: metadata_12345
        tenant: tenant_12345
      properties:
        channel_id:
          description: The unique identifier for the channel.
          format: uuid
          type: string
        content:
          description: The content of the guide.
          type: object
        data:
          description: The data of the guide.
          type: object
        guide_id:
          description: The unique identifier for the guide.
          format: uuid
          type: string
        guide_key:
          description: The key of the guide.
          type: string
        guide_step_ref:
          description: The step reference of the guide.
          type: string
        is_final:
          description: Whether the guide is final.
          type: boolean
        metadata:
          description: The metadata of the guide.
          type: object
        tenant:
          description: The tenant id of the guide.
          nullable: true
          type: string
      required:
        - channel_id
        - guide_id
        - guide_key
        - guide_step_ref
      title: GuideActionRequest
      type: object
    BulkUpsertSubscriptionsRequest:
      description: A request to upsert subscriptions for a set of objects in a single collection.
      example:
        subscriptions:
          - id: project-1
            properties: null
            recipients:
              - id: user_1
      properties:
        subscriptions:
          description: A list of subscriptions.
          items:
            properties:
              id:
                description: Unique identifier for the subscription.
                type: string
              properties:
                additionalProperties: true
                description: The custom properties associated with the recipients of the subscription.
                nullable: true
                type: object
              recipients:
                description: The recipients of the subscription.
                items:
                  $ref: '#/components/schemas/RecipientRequest'
                type: array
            required:
              - id
              - recipients
            type: object
          type: array
      required:
        - subscriptions
      title: BulkUpsertSubscriptionsRequest
      type: object
    ListSchedulesResponse:
      description: A response containing a list of schedules.
      example:
        entries:
          - __typename: Schedule
            actor: null
            data: null
            id: 123e4567-e89b-12d3-a456-426614174000
            inserted_at: '2021-01-01T00:00:00Z'
            last_occurrence_at: null
            next_occurrence_at: null
            recipient:
              __typename: User
              avatar: null
              created_at: null
              email: jane@ingen.net
              id: jane
              name: Jane Doe
              phone_number: null
              timezone: null
              updated_at: '2024-05-22T12:00:00Z'
            repeats:
              - __typename: ScheduleRepeat
                day_of_month: null
                days:
                  - mon
                  - tue
                  - wed
                  - thu
                  - fri
                  - sat
                  - sun
                frequency: daily
                hours: null
                interval: 1
                minutes: null
            tenant: null
            updated_at: '2021-01-01T00:00:00Z'
            workflow: workflow_123
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of schedules.
          items:
            $ref: '#/components/schemas/Schedule'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      required:
        - entries
        - page_info
      title: ListSchedulesResponse
      type: object
    MessageChatContent:
      description: The content of a chat message.
      example:
        __typename: MessageChatContent
        connection:
          access_token: null
          channel_id: null
          user_id: null
        metadata: null
        template:
          blocks:
            - content: content
              name: name
              type: text
          json_content: null
          summary: This is a summary
      properties:
        __typename:
          description: The typename of the schema.
          example: MessageChatContent
          nullable: false
          type: string
        connection:
          additionalProperties: true
          description: The channel data connection from the recipient to the underlying provider.
          nullable: false
          type: object
        metadata:
          additionalProperties: true
          description: Additional metadata associated with the chat message.
          example:
            foo: bar
          nullable: true
          type: object
        template:
          description: The template structure for the chat message.
          nullable: false
          properties:
            blocks:
              description: The blocks of the message in a chat.
              items:
                $ref: '#/components/schemas/Block'
              nullable: true
              type: array
            json_content:
              additionalProperties: true
              description: The JSON content of the message.
              nullable: true
              type: object
            summary:
              description: The summary of the chat message.
              nullable: true
              type: string
          type: object
      required:
        - __typename
        - template
        - connection
      title: MessageChatContent
      type: object
    PreferenceSetRequestCategories:
      additionalProperties:
        $ref: '#/components/schemas/PreferenceSetWorkflowCategorySetting'
      description: An object where the key is the category and the values are the preference settings for that category.
      example:
        marketing:
          channel_types:
            email: false
      title: PreferenceSetRequestCategories
      type: object
    BatchGetMessageContentsResponse:
      description: A list of message contents
      example:
        - __typename: MessageContent
          data:
            __typename: MessageSmsContent
            body: Hello, world!
            to: user_123
          inserted_at: '2021-01-01T00:00:00Z'
          message_id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
      items:
        $ref: '#/components/schemas/MessageContents'
      title: BatchGetMessageContentsResponse
      type: array
    DiscordChannelData:
      description: Discord channel data.
      example:
        connections:
          - channel_id: '123456789012345678'
      properties:
        connections:
          description: List of Discord channel connections.
          items:
            description: Discord channel connection, either a channel connection or an incoming webhook connection.
            oneOf:
              - $ref: '#/components/schemas/DiscordChannelConnection'
              - $ref: '#/components/schemas/DiscordIncomingWebhookConnection'
            type: object
          nullable: false
          type: array
      required:
        - connections
      title: DiscordChannelData
      type: object
    BulkDeleteUsersRequest:
      description: A request to delete users in bulk.
      example:
        user_ids:
          - user_1
          - user_2
      properties:
        user_ids:
          description: A list of user IDs.
          items:
            description: The ID for the user that you set when identifying them in Knock.
            type: string
          type: array
      required:
        - user_ids
      title: BulkDeleteUsersRequest
      type: object
    ListSubscriptionsResponse:
      description: A response containing a list of subscriptions.
      example:
        entries:
          - __typename: Subscription
            inserted_at: '2021-01-01T00:00:00Z'
            object:
              __typename: Object
              collection: projects
              created_at: null
              id: project_1
              name: My first project
              updated_at: '2024-05-22T12:00:00Z'
            recipient:
              __typename: User
              avatar: null
              created_at: null
              email: jane@ingen.net
              id: jane
              name: Jane Doe
              phone_number: null
              timezone: null
              updated_at: '2024-05-22T12:00:00Z'
            updated_at: '2021-01-01T00:00:00Z'
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of subscriptions.
          items:
            $ref: '#/components/schemas/Subscription'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      required:
        - entries
        - page_info
      title: ListSubscriptionsResponse
      type: object
    MsTeamsAuthCheckResponse:
      description: The response from a Microsoft Teams auth check request.
      example:
        connection:
          ok: true
      properties:
        connection:
          description: A Microsoft Teams connection object.
          properties:
            ok:
              description: Whether the Microsoft Teams connection is valid.
              nullable: false
              type: boolean
            reason:
              description: The reason for the Microsoft Teams connection if it is not valid.
              nullable: true
              type: string
          required:
            - ok
          type: object
      required:
        - connection
      title: MsTeamsAuthCheckResponse
      type: object
    SlackAuthCheckResponse:
      description: The response from a Slack auth check request.
      example:
        connection:
          ok: true
      properties:
        connection:
          description: A Slack connection object.
          properties:
            ok:
              description: Whether the Slack connection is valid.
              nullable: false
              type: boolean
            reason:
              description: The reason for the Slack connection if it is not valid.
              nullable: true
              type: string
          required:
            - ok
          type: object
      required:
        - connection
      title: SlackAuthCheckResponse
      type: object
    RecipientReference:
      description: A reference to a recipient, either a user identifier (string) or an object reference (id, collection).
      example: user_123
      oneOf:
        - description: The id of the user.
          example: user_123
          nullable: false
          title: UserReference
          type: string
        - description: A reference to a recipient object.
          example:
            collection: projects
            id: project_123
          properties:
            collection:
              description: The collection the recipient object belongs to.
              example: projects
              nullable: false
              type: string
            id:
              description: An identifier for the recipient object.
              example: project_123
              nullable: false
              type: string
          title: ObjectReference
          type: object
      title: RecipientReference
    BatchMessagesInteractedRequest:
      description: A request to batch mark messages as interacted with.
      example:
        message_ids:
          - 1jNaXzB2RZX3LY8wVQnfCKyPnv7
        metadata:
          key: value
      properties:
        message_ids:
          description: The message IDs to batch mark as interacted with.
          items:
            type: string
          type: array
        metadata:
          additionalProperties: true
          description: Metadata about the interaction.
          example:
            key: value
          nullable: true
          type: object
      required:
        - message_ids
      title: BatchMessagesInteractedRequest
      type: object
    UserReference:
      description: The id of the user.
      example: user_123
      nullable: false
      title: UserReference
      type: string
    SetObjectRequest:
      additionalProperties: true
      description: A set of parameters to set an object with. Does not include the object id or collection.
      example:
        description: My product description
        name: My product
        price: 100
      properties:
        channel_data:
          description: A set of channel data for the object. This is a map of channel IDs to channel data.
          oneOf:
            - $ref: '#/components/schemas/InlineChannelDataRequest'
            - nullable: true
        preferences:
          description: >-
            A set of preferences for the object. This is a map of preference set names to preference set
            values.
          oneOf:
            - $ref: '#/components/schemas/InlinePreferenceSetRequest'
            - nullable: true
      title: SetObjectRequest
      type: object
    UserInAppFeedSettingsResponse:
      description: The response for the user's feed settings.
      example:
        features:
          branding_required: true
      properties:
        features:
          description: Features configuration for the user's feed.
          properties:
            branding_required:
              description: Whether branding is required for the user's feed.
              type: boolean
          required:
            - branding_required
          type: object
      required:
        - features
      title: UserInAppFeedSettingsResponse
      type: object
    ListObjectPreferenceSetsResponse:
      description: A list of preference sets for the object
      example:
        - __typename: PreferenceSet
          categories:
            marketing: false
            transactional:
              channel_types:
                email: false
          channel_types:
            email: true
            push: false
            sms:
              conditions:
                - argument: US
                  operator: equal_to
                  variable: recipient.country_code
          id: default
          workflows: null
      items:
        $ref: '#/components/schemas/PreferenceSet'
      title: ListObjectPreferenceSetsResponse
      type: array
    Tenant:
      additionalProperties: true
      description: A tenant entity.
      example:
        __typename: Tenant
        id: tenant_123
        name: ACME Corp, Inc.
      properties:
        __typename:
          description: The typename of the schema.
          example: Tenant
          type: string
        id:
          description: The unique identifier for the tenant.
          nullable: false
          type: string
      required:
        - __typename
        - id
      title: Tenant
      type: object
    BulkSetUserPreferencesRequest:
      description: A request to set preferences for a set of users in bulk.
      example:
        preferences:
          categories:
            marketing: false
            transactional:
              channel_types:
                email: false
          channel_types:
            email: true
          workflows:
            dinosaurs-loose:
              channel_types:
                email: false
        user_ids:
          - user_1
          - user_2
      properties:
        preferences:
          $ref: '#/components/schemas/PreferenceSetRequest'
        user_ids:
          description: A list of user IDs.
          items:
            description: The ID for the user that you set when identifying them in Knock.
            type: string
          type: array
      required:
        - preferences
        - user_ids
      title: BulkSetUserPreferencesRequest
      type: object
    MessageInteractedRequest:
      description: A request to mark a message as interacted with.
      example:
        metadata:
          key: value
      properties:
        metadata:
          additionalProperties: true
          description: Metadata about the interaction.
          example:
            key: value
          type: object
      title: MessageInteractedRequest
      type: object
    InlineIdentifyObjectRequest:
      additionalProperties: true
      description: A custom object entity which belongs to a collection.
      example:
        collection: projects
        id: project_1
        name: My project
      properties:
        channel_data:
          description: A set of channel data for the object. This is a map of channel IDs to channel data.
          oneOf:
            - $ref: '#/components/schemas/InlineChannelDataRequest'
            - nullable: true
        collection:
          description: The collection this object belongs to.
          nullable: false
          type: string
        created_at:
          description: Timestamp when the resource was created.
          format: date-time
          nullable: true
          type: string
        id:
          description: Unique identifier for the object.
          nullable: false
          type: string
        preferences:
          description: >-
            A set of preferences for the object. This is a map of preference set names to preference set
            values.
          oneOf:
            - $ref: '#/components/schemas/InlinePreferenceSetRequest'
            - nullable: true
      required:
        - id
        - collection
      title: InlineIdentifyObjectRequest
      type: object
    MessageInAppFeedButtonSetBlock:
      description: A button set block in a message in an app feed.
      example:
        buttons:
          - action: action_1
            label: Action 1
            name: primary
        name: actions
        type: button_set
      properties:
        buttons:
          description: A list of buttons in an in app feed message.
          items:
            description: A button in an in app feed message.
            nullable: false
            properties:
              action:
                description: The action to take when the button is clicked.
                nullable: false
                type: string
              label:
                description: The label of the button.
                nullable: false
                type: string
              name:
                description: The name of the button.
                nullable: false
                type: string
            required:
              - action
              - label
              - name
            type: object
          nullable: false
          type: array
        name:
          description: The name of the button set in a message in an app feed.
          nullable: false
          type: string
        type:
          description: The type of block in a message in an app feed.
          enum:
            - button_set
          nullable: false
          type: string
      required:
        - type
        - name
        - buttons
      title: MessageInAppFeedButtonSetBlock
      type: object
    PushChannelData:
      description: The content of a push notification.
      example:
        __typename: PushChannelData
        tokens:
          - push_token_1
      properties:
        __typename:
          description: The typename of the schema.
          enum:
            - PushChannelData
          example: PushChannelData
          type: string
        tokens:
          description: A list of push channel tokens.
          example:
            - push_token_1
            - push_token_2
          items:
            description: The device token to send the push notification to.
            nullable: false
            type: string
          nullable: false
          type: array
      required:
        - __typename
        - tokens
      title: PushChannelData
      type: object
    GuideActionResponse:
      description: A response for a guide action.
      example:
        status: ok
      properties:
        status:
          description: The status of a guide's action.
          example: ok
          type: string
      required:
        - status
      title: GuideActionResponse
      type: object
    MessagePushContent:
      description: The content of a push notification.
      example:
        __typename: MessagePushContent
        body: Hello, world!
        data: null
        title: Hello, world!
        token: xoxo-1234567890
      properties:
        __typename:
          description: The typename of the schema.
          example: MessagePushContent
          nullable: false
          type: string
        body:
          description: The content body of the push notification.
          nullable: false
          type: string
        data:
          additionalProperties: true
          description: Additional data payload for the push notification.
          nullable: true
          type: object
        title:
          description: The title of the push notification.
          nullable: false
          type: string
        token:
          description: The device token to send the push notification to.
          nullable: false
          type: string
      required:
        - __typename
        - title
        - body
        - token
      title: MessagePushContent
      type: object
    PreferenceSet:
      description: >-
        A preference set determines whether a recipient should receive a particular type of notification. By
        default all preferences are opted in unless a preference explicitly opts the recipient out of the
        notification
      example:
        __typename: PreferenceSet
        categories:
          marketing: false
          transactional:
            channel_types:
              email: false
        channel_types:
          email: true
          push: false
          sms:
            conditions:
              - argument: US
                operator: equal_to
                variable: recipient.country_code
        id: default
        workflows: null
      properties:
        __typename:
          description: The typename of the schema.
          example: PreferenceSet
          type: string
        categories:
          anyOf:
            - additionalProperties:
                $ref: '#/components/schemas/PreferenceSetWorkflowCategorySetting'
              description: >-
                An object where the key is the category and the values are the preference settings for that
                category.
              example:
                marketing:
                  channel_types:
                    email: false
              title: PreferenceSetCategories
              type: object
            - nullable: true
          description: >-
            An object where the key is the category and the values are the preference settings for that
            category.
        channel_types:
          anyOf:
            - $ref: '#/components/schemas/PreferenceSetChannelTypes'
            - nullable: true
          description: A map of preference set channel types.
        id:
          description: Unique identifier for the preference set.
          example: default
          type: string
        workflows:
          anyOf:
            - additionalProperties:
                $ref: '#/components/schemas/PreferenceSetWorkflowCategorySetting'
              description: >-
                An object where the key is the workflow key and the values are the preference settings for
                that workflow.
              example:
                dinosaurs-loose:
                  channel_types:
                    email: false
              title: PreferenceSetWorkflows
              type: object
            - nullable: true
          description: >-
            An object where the key is the workflow key and the values are the preference settings for that
            workflow.
      required:
        - __typename
        - id
      title: PreferenceSet
      type: object
    ScheduleRepeatRule:
      description: The repeat rule for the schedule.
      example:
        __typename: ScheduleRepeat
        day_of_month: null
        days:
          - mon
          - tue
          - wed
          - thu
          - fri
          - sat
          - sun
        frequency: daily
        hours: null
        interval: 1
        minutes: null
      properties:
        __typename:
          description: The typename of the schema.
          example: ScheduleRepeat
          type: string
        day_of_month:
          description: The day of the month to repeat the schedule.
          example: 1
          nullable: true
          type: integer
        days:
          description: The days of the week to repeat the schedule.
          example:
            - mon
            - tue
            - wed
            - thu
            - fri
          items:
            description: An identifier for a day of the week.
            enum:
              - mon
              - tue
              - wed
              - thu
              - fri
              - sat
              - sun
            type: string
          nullable: true
          type: array
        frequency:
          description: The frequency of the schedule.
          enum:
            - daily
            - weekly
            - monthly
            - hourly
          example: daily
          type: string
        hours:
          description: The hour of the day to repeat the schedule.
          example: 0
          nullable: true
          type: integer
        interval:
          default: 1
          description: The interval of the schedule.
          example: 1
          type: integer
        minutes:
          description: The minute of the hour to repeat the schedule.
          example: 0
          nullable: true
          type: integer
      required:
        - __typename
        - frequency
      title: ScheduleRepeatRule
      type: object
    CreateSchedulesRequest:
      description: A request to create a schedule.
      example:
        data:
          key: value
        ending_at: null
        recipients:
          - user_123
        repeats:
          - __typename: ScheduleRepeat
            day_of_month: null
            days:
              - mon
              - tue
              - wed
              - thu
              - fri
              - sat
              - sun
            frequency: daily
            hours: null
            interval: 1
            minutes: null
        scheduled_at: null
        tenant: acme_corp
        workflow: comment-created
      properties:
        data:
          additionalProperties: true
          description: An optional map of data to pass into the workflow execution.
          nullable: true
          type: object
        ending_at:
          description: The ending date and time for the schedule.
          format: date-time
          nullable: true
          type: string
        recipients:
          description: >-
            The recipients to trigger the workflow for. Can inline identify users, objects, or use a list of
            user ids. Cannot exceed 1000 recipients in a single trigger.
          items:
            $ref: '#/components/schemas/RecipientReference'
          type: array
        repeats:
          description: The repeat rule for the schedule.
          items:
            $ref: '#/components/schemas/ScheduleRepeatRule'
          type: array
        scheduled_at:
          description: The starting date and time for the schedule.
          format: date-time
          nullable: true
          type: string
        tenant:
          anyOf:
            - $ref: '#/components/schemas/InlineTenantRequest'
            - nullable: true
          description: >-
            The tenant to trigger the workflow for. Triggering with a tenant will use any tenant-level
            overrides associated with the tenant object, and all messages produced from workflow runs will be
            tagged with the tenant.
        workflow:
          description: The key of the workflow.
          nullable: false
          type: string
      required:
        - workflow
        - repeats
        - recipients
      title: CreateSchedulesRequest
      type: object
    MessageDeliveryLog:
      description: A message delivery log.
      example:
        __typename: MessageDeliveryLog
        environment_id: 123e4567-e89b-12d3-a456-426614174000
        id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
        inserted_at: '2021-01-01T00:00:00Z'
        request:
          body:
            html_content: <html></html>
          headers:
            Content-Type: application/json
          host: localhost
          method: GET
          path: /
          query: '?foo=bar'
        response:
          body:
            success: true
          headers:
            Content-Type: application/json
          status: 200
        service_name: Postmark
      properties:
        __typename:
          description: The typename of the schema.
          example: MessageDeliveryLog
          nullable: false
          type: string
        environment_id:
          description: The ID of the environment in which the message delivery occurred.
          example: 123e4567-e89b-12d3-a456-426614174000
          format: uuid
          nullable: false
          type: string
        id:
          description: The unique identifier for the message delivery log.
          example: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
          nullable: false
          type: string
        inserted_at:
          description: Timestamp when the message delivery log was created.
          example: '2021-01-01T00:00:00Z'
          nullable: false
          type: string
        request:
          $ref: '#/components/schemas/MessageDeliveryLogRequest'
        response:
          $ref: '#/components/schemas/MessageDeliveryLogResponse'
        service_name:
          description: The name of the service that processed the delivery.
          example: Postmark
          nullable: false
          type: string
      required:
        - __typename
        - id
        - environment_id
        - request
        - response
        - service_name
        - inserted_at
      title: MessageDeliveryLog
      type: object
    ListObjectsResponse:
      description: A paginated list of objects in a collection.
      example:
        entries:
          - __typename: Object
            collection: projects
            created_at: null
            id: project_1
            name: My first project
            updated_at: '2024-05-22T12:00:00Z'
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of objects.
          items:
            $ref: '#/components/schemas/Object'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      required:
        - entries
        - page_info
      title: ListObjectsResponse
      type: object
    ObjectReference:
      description: A reference to a recipient object.
      example:
        collection: projects
        id: project_123
      properties:
        collection:
          description: The collection the recipient object belongs to.
          example: projects
          nullable: false
          type: string
        id:
          description: An identifier for the recipient object.
          example: project_123
          nullable: false
          type: string
      title: ObjectReference
      type: object
    PreferenceSetRequestWorkflows:
      additionalProperties:
        $ref: '#/components/schemas/PreferenceSetWorkflowCategorySetting'
      description: >-
        An object where the key is the workflow key and the values are the preference settings for that
        workflow.
      example:
        dinosaurs-loose:
          channel_types:
            email: false
      title: PreferenceSetRequestWorkflows
      type: object
    PreferenceSetWorkflowCategorySetting:
      description: Workflow or category preferences within a preference set
      example:
        channel_types:
          email: false
      oneOf:
        - example: false
          type: boolean
        - description: The settings object for a workflow or category, where you can specify channel types or conditions.
          example:
            channel_types:
              email: false
            conditions: null
          properties:
            channel_types:
              anyOf:
                - $ref: '#/components/schemas/PreferenceSetChannelTypes'
                - nullable: true
              description: A map of preference set channel types.
            conditions:
              description: A list of conditions to apply to a channel type.
              items:
                $ref: '#/components/schemas/Condition'
              nullable: true
              type: array
          title: PreferenceSetWorkflowCategorySettingObject
          type: object
      title: PreferenceSetWorkflowCategorySetting
      type: object
    InAppFeedItem:
      description: An in-app feed message in a user's feed.
      example:
        __typename: FeedItem
        activities:
          - __typename: Activity
            actor: null
            data:
              foo: bar
            id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
            inserted_at: '2024-01-01T00:00:00Z'
            recipient:
              __typename: User
              avatar: null
              created_at: null
              email: jane@ingen.net
              id: jane
              name: Jane Doe
              phone_number: null
              timezone: null
              updated_at: '2024-05-22T12:00:00Z'
            updated_at: '2024-01-01T00:00:00Z'
        actors:
          - __typename: User
            avatar: null
            created_at: null
            email: jane@ingen.net
            id: jane
            name: Jane Doe
            phone_number: null
            timezone: null
            updated_at: '2024-05-22T12:00:00Z'
        blocks:
          - content: This is a message in an app feed
            name: body
            rendered: <p>This is a message in an app feed</p>
            type: markdown
        data:
          foo: bar
        id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
        inserted_at: '2021-01-01T00:00:00Z'
        source:
          __typename: Workflow
          categories:
            - collaboration
          key: my_source
          version_id: 123e4567-e89b-12d3-a456-426614174000
        tenant: acme_corp
        total_activities: 10
        total_actors: 5
        updated_at: '2021-01-01T00:00:00Z'
      properties:
        __typename:
          description: The typename of the schema.
          example: FeedItem
          type: string
        activities:
          description: List of activities associated with this feed item.
          items:
            $ref: '#/components/schemas/Activity'
          type: array
        actors:
          description: List of actors associated with this feed item.
          items:
            $ref: '#/components/schemas/Recipient'
          type: array
        archived_at:
          description: Timestamp when the feed item was archived.
          nullable: true
          type: string
        blocks:
          description: Content blocks that make up the feed item.
          items:
            description: A content block for the feed, can be content or a button set.
            nullable: false
            oneOf:
              - $ref: '#/components/schemas/MessageInAppFeedContentBlock'
              - $ref: '#/components/schemas/MessageInAppFeedButtonSetBlock'
            type: object
          type: array
        clicked_at:
          description: Timestamp when the feed item was clicked.
          nullable: true
          type: string
        data:
          additionalProperties: true
          description: Additional data associated with the feed item.
          nullable: true
          type: object
        id:
          description: Unique identifier for the feed.
          example: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
          type: string
        inserted_at:
          description: Timestamp when the resource was created.
          nullable: false
          type: string
        interacted_at:
          description: Timestamp when the feed item was interacted with.
          nullable: true
          type: string
        link_clicked_at:
          description: Timestamp when a link within the feed item was clicked.
          nullable: true
          type: string
        read_at:
          description: Timestamp when the feed item was marked as read.
          nullable: true
          type: string
        seen_at:
          description: Timestamp when the feed item was marked as seen.
          nullable: true
          type: string
        source:
          description: Source information for the feed item.
          nullable: false
          properties:
            __typename:
              description: The typename of the schema.
              example: Workflow
              type: string
            categories:
              description: Categories this workflow belongs to.
              items:
                nullable: false
                type: string
              type: array
            key:
              description: The key of the workflow.
              nullable: false
              type: string
            version_id:
              description: The workflow version ID.
              format: uuid
              nullable: false
              type: string
          required:
            - __typename
            - key
            - version_id
            - categories
          type: object
        tenant:
          description: Tenant ID that the feed item belongs to.
          nullable: true
          type: string
        total_activities:
          description: Total number of activities related to this feed item.
          example: 10
          type: integer
        total_actors:
          description: Total number of actors related to this feed item.
          example: 5
          type: integer
        updated_at:
          description: The timestamp when the resource was last updated.
          nullable: false
          type: string
      required:
        - __typename
        - id
        - inserted_at
        - updated_at
        - actors
        - activities
        - blocks
        - source
        - tenant
        - total_activities
        - total_actors
        - data
      title: InAppFeedItem
      type: object
    MessageDeliveryLogResponse:
      description: A message delivery log response.
      example:
        body:
          success: true
        headers:
          Content-Type: application/json
        status: 200
      properties:
        body:
          description: The body content that was received with the response.
          oneOf:
            - type: string
            - additionalProperties: true
              type: object
          type: object
        headers:
          additionalProperties: true
          description: The headers that were received with the response.
          nullable: true
          type: object
        status:
          description: The HTTP status code of the response.
          example: 200
          nullable: false
          type: integer
      title: MessageDeliveryLogResponse
      type: object
    Notify Request:
      description: A request to trigger a notification workflow.
      example:
        actor: user_123
        cancellation_key: comment_123
        data:
          comment: Great work on this feature!
          url: https://example.com/projects/123/comments/456
        name: new-comment
        recipients:
          - user_456
          - collection: projects
            id: project_789
      properties:
        actor:
          $ref: '#/components/schemas/RecipientReference'
        cancellation_key:
          description: >-
            The cancellation key provided during the initial notify call. If used in a cancel request, will
            cancel the notification for the recipients specified in the cancel request.
          nullable: true
          type: string
        data:
          additionalProperties: true
          description: An optional map of data to pass into the workflow execution.
          nullable: true
          type: object
        name:
          description: The key of the workflow to trigger.
          type: string
        recipients:
          description: A list of recipients.
          items:
            $ref: '#/components/schemas/RecipientReference'
          type: array
      required:
        - name
        - actor
        - recipients
      title: Notify Request
      type: object
    ListMessageDeliveryLogsResponse:
      description: A message delivery log response.
      example:
        entries:
          - __typename: MessageDeliveryLog
            environment_id: 123e4567-e89b-12d3-a456-426614174000
            id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
            inserted_at: '2021-01-01T00:00:00Z'
            request:
              body:
                html_content: <html></html>
              headers:
                Content-Type: application/json
              host: localhost
              method: GET
              path: /
              query: '?foo=bar'
            response:
              body:
                success: true
              headers:
                Content-Type: application/json
              status: 200
            service_name: Postmark
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of message delivery logs.
          items:
            $ref: '#/components/schemas/MessageDeliveryLog'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      required:
        - entries
        - page_info
      title: ListMessageDeliveryLogsResponse
      type: object
    UserRecipient:
      description: The id of the user.
      example: user_123
      title: UserRecipient
      type: string
    ListTenantsResponse:
      description: A response containing a list of tenants.
      example:
        entries:
          - __typename: Tenant
            id: tenant_123
            name: ACME Corp, Inc.
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of tenants.
          items:
            $ref: '#/components/schemas/Tenant'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      required:
        - entries
        - page_info
      title: ListTenantsResponse
      type: object
    ListActivitiesResponse:
      description: A paginated list of activities.
      example:
        entries:
          - __typename: Activity
            actor: null
            data:
              foo: bar
            id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
            inserted_at: '2024-01-01T00:00:00Z'
            recipient:
              __typename: User
              avatar: null
              created_at: null
              email: jane@ingen.net
              id: jane
              name: Jane Doe
              phone_number: null
              timezone: null
              updated_at: '2024-05-22T12:00:00Z'
            updated_at: '2024-01-01T00:00:00Z'
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of activities.
          items:
            $ref: '#/components/schemas/Activity'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      required:
        - entries
        - page_info
      title: ListActivitiesResponse
      type: object
    SlackChannelDataTokenObject:
      description: A Slack connection token.
      example:
        access_token: xoxb-1234567890
      nullable: true
      properties:
        access_token:
          description: A Slack access token.
          example: xoxb-1234567890
          nullable: true
          type: string
      required:
        - access_token
      title: SlackChannelDataTokenObject
      type: object
    Recipient:
      description: A recipient of a notification, which is either a user or an object.
      discriminator: __typename
      example:
        __typename: User
        avatar: null
        created_at: null
        email: jane@ingen.net
        id: jane
        name: Jane Doe
        phone_number: null
        timezone: null
        updated_at: '2024-05-22T12:00:00Z'
      oneOf:
        - $ref: '#/components/schemas/User'
        - $ref: '#/components/schemas/Object'
      title: Recipient
      type: object
    TenantRequest:
      additionalProperties: true
      description: A tenant to be set in the system. You can supply any additional properties on the tenant object.
      example:
        id: tenant_123
        name: ACME Corp, Inc.
        settings:
          branding:
            icon_url: https://example.com/icon.png
            logo_url: https://example.com/logo.png
            primary_color: '#000000'
            primary_color_contrast: '#FFFFFF'
      properties:
        channel_data:
          description: The channel data for the tenant.
          oneOf:
            - nullable: true
            - $ref: '#/components/schemas/InlineChannelDataRequest'
        id:
          description: The unique identifier for the tenant.
          type: string
        preferences:
          description: The preferences for the tenant.
          oneOf:
            - nullable: true
            - $ref: '#/components/schemas/InlinePreferenceSetRequest'
        settings:
          description: The settings for the tenant. Includes branding and preference set.
          properties:
            branding:
              description: The branding for the tenant.
              properties:
                icon_url:
                  description: The icon URL for the tenant.
                  nullable: true
                  type: string
                logo_url:
                  description: The logo URL for the tenant.
                  nullable: true
                  type: string
                primary_color:
                  description: The primary color for the tenant.
                  nullable: true
                  type: string
                primary_color_contrast:
                  description: The primary color contrast for the tenant.
                  nullable: true
                  type: string
              type: object
            preference_set:
              description: The preference set for the tenant. Used to override the default preference set.
              oneOf:
                - nullable: true
                - $ref: '#/components/schemas/PreferenceSetRequest'
          type: object
      required:
        - id
      title: TenantRequest
      type: object
    PageInfo:
      description: Pagination information for a list of resources.
      example:
        __typename: PageInfo
        after: null
        before: null
        page_size: 25
      properties:
        __typename:
          description: The typename of the schema.
          example: PageInfo
          type: string
        after:
          description: The cursor to fetch entries after.
          nullable: true
          type: string
        before:
          description: The cursor to fetch entries before.
          nullable: true
          type: string
        page_size:
          description: The number of items per page.
          type: integer
      required:
        - __typename
        - page_size
      title: PageInfo
      type: object
    UserInAppFeedResponse:
      description: A paginated list of feed items.
      example:
        entries:
          - __typename: FeedItem
            activities:
              - __typename: Activity
                actor: null
                data:
                  foo: bar
                id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
                inserted_at: '2024-01-01T00:00:00Z'
                recipient:
                  __typename: User
                  avatar: null
                  created_at: null
                  email: jane@ingen.net
                  id: jane
                  name: Jane Doe
                  phone_number: null
                  timezone: null
                  updated_at: '2024-05-22T12:00:00Z'
                updated_at: '2024-01-01T00:00:00Z'
            actors:
              - __typename: User
                avatar: null
                created_at: null
                email: jane@ingen.net
                id: jane
                name: Jane Doe
                phone_number: null
                timezone: null
                updated_at: '2024-05-22T12:00:00Z'
            blocks:
              - content: This is a message in an app feed
                name: body
                rendered: <p>This is a message in an app feed</p>
                type: markdown
            data:
              foo: bar
            id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
            inserted_at: '2021-01-01T00:00:00Z'
            source:
              __typename: Workflow
              categories:
                - collaboration
              key: my_source
              version_id: 123e4567-e89b-12d3-a456-426614174000
            tenant: acme_corp
            total_activities: 10
            total_actors: 5
            updated_at: '2021-01-01T00:00:00Z'
        meta:
          __typename: FeedMetadata
          total_count: 100
          unread_count: 10
          unseen_count: 5
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
        vars:
          foo: bar
      properties:
        entries:
          description: The list of feed items in the user's feed.
          items:
            $ref: '#/components/schemas/InAppFeedItem'
          nullable: false
          type: array
        meta:
          description: The metadata for the user's feed.
          example:
            __typename: FeedMetadata
            total_count: 100
            unread_count: 10
            unseen_count: 5
          properties:
            __typename:
              description: The typename of the schema.
              example: FeedMetadata
              type: string
            total_count:
              description: The total number of feed items in the user's feed.
              example: 100
              type: integer
            unread_count:
              description: The number of unread feed items in the user's feed.
              example: 10
              type: integer
            unseen_count:
              description: The number of unseen feed items in the user's feed.
              example: 5
              type: integer
          required:
            - __typename
            - total_count
            - unread_count
            - unseen_count
          type: object
        page_info:
          $ref: '#/components/schemas/PageInfo'
        vars:
          additionalProperties: true
          description: Additional variables for the feed item.
          type: object
      required:
        - entries
        - page_info
        - vars
        - meta
      title: UserInAppFeedResponse
      type: object
    RecipientRequest:
      description: >-
        Specifies a recipient in a request. This can either be a user identifier (string), an inline user
        request (object), or an inline object request, which is determined by the presence of a `collection`
        property.
      example:
        id: user_1
      nullable: false
      oneOf:
        - description: The id of the user.
          example: user_123
          title: UserRecipient
          type: string
        - $ref: '#/components/schemas/InlineIdentifyUserRequest'
        - $ref: '#/components/schemas/InlineIdentifyObjectRequest'
      title: RecipientRequest
    SlackTokenConnection:
      description: A Slack connection token.
      example:
        access_token: xoxb-1234567890
        channel_id: C01234567890
        user_id: U01234567890
      properties:
        access_token:
          description: A Slack access token.
          example: xoxb-1234567890
          nullable: true
          type: string
        channel_id:
          description: A Slack channel ID from the Slack provider.
          example: C01234567890
          nullable: true
          type: string
        user_id:
          description: A Slack user ID from the Slack provider.
          example: U01234567890
          nullable: true
          type: string
      title: SlackTokenConnection
      type: object
    IdentifyUserRequest:
      additionalProperties: true
      description: >-
        A set of parameters to identify a user with. Does not include the user ID, as that's specified
        elsewhere in the request. You can supply any additional properties you'd like to upsert for the user.
      example:
        email: jane@ingen.net
        name: Jane Doe
        timezone: America/New_York
      properties:
        channel_data:
          description: A set of channel data for the user. This is a map of channel IDs to channel data.
          oneOf:
            - nullable: true
            - $ref: '#/components/schemas/InlineChannelDataRequest'
        created_at:
          description: The creation date of the user from your system.
          format: date-time
          nullable: true
          type: string
        preferences:
          description: A set of preferences for the user.
          oneOf:
            - nullable: true
            - $ref: '#/components/schemas/InlinePreferenceSetRequest'
      title: IdentifyUserRequest
      type: object
    ChannelsForMsTeamsProviderResponse:
      description: The response from a Microsoft Teams provider request, containing a list of channels.
      example:
        ms_teams_channels:
          - displayName: General
            id: channel-id-1
      properties:
        ms_teams_channels:
          description: List of Microsoft Teams channels.
          items:
            properties:
              createdDateTime:
                description: Microsoft Teams channel created date and time.
                nullable: false
                type: string
              description:
                description: Microsoft Teams channel description.
                nullable: true
                type: string
              displayName:
                description: Microsoft Teams channel name.
                nullable: false
                type: string
              id:
                description: Microsoft Teams channel ID.
                nullable: false
                type: string
              isArchived:
                description: Whether the Microsoft Teams channel is archived.
                nullable: false
                type: boolean
              membershipType:
                description: Microsoft Teams channel membership type.
                nullable: false
                type: string
            required:
              - id
              - displayName
            type: object
          type: array
      required:
        - ms_teams_channels
      title: ChannelsForMsTeamsProviderResponse
      type: object
    BulkSetObjectsRequest:
      description: A request to set objects in bulk.
      example:
        objects:
          - collection: projects
            id: project_1
            name: My project
      properties:
        objects:
          description: A list of objects.
          items:
            $ref: '#/components/schemas/InlineIdentifyObjectRequest'
          type: array
      required:
        - objects
      title: BulkSetObjectsRequest
      type: object
    DeleteSchedulesRequest:
      description: A request to delete a schedule.
      example:
        schedule_ids:
          - 123e4567-e89b-12d3-a456-426614174000
      properties:
        schedule_ids:
          description: A list of schedule IDs.
          items:
            description: Unique identifier for the schedule.
            type: string
          type: array
      required:
        - schedule_ids
      title: DeleteSchedulesRequest
      type: object
    Object:
      additionalProperties: true
      description: A custom object entity which belongs to a collection.
      example:
        __typename: Object
        collection: projects
        created_at: null
        id: project_1
        name: My first project
        updated_at: '2024-05-22T12:00:00Z'
      properties:
        __typename:
          description: The typename of the schema.
          example: Object
          type: string
        collection:
          description: The collection this object belongs to.
          type: string
        created_at:
          description: Timestamp when the resource was created.
          format: date-time
          nullable: true
          type: string
        id:
          description: Unique identifier for the object.
          type: string
        updated_at:
          description: The timestamp when the resource was last updated.
          format: date-time
          type: string
      required:
        - __typename
        - id
        - collection
        - updated_at
      title: Object
      type: object
    GuidesResponse:
      description: A response for a list of guides.
      example:
        guides:
          - content: Welcome to our application!
            id: 323e4567-e89b-12d3-a456-426614174000
            metadata:
              dismissable: true
              position: bottom
            title: Welcome Guide
        recipient:
          id: user_12345
      properties:
        guides:
          description: A list of guides.
          items:
            properties:
              content:
                description: The content of the guide.
                type: string
              id:
                description: The unique identifier for the guide.
                format: uuid
                type: string
              metadata:
                additionalProperties: true
                description: The metadata of the guide.
                type: object
              title:
                description: The title of the guide.
                type: string
            type: object
          type: array
        recipient:
          description: The recipient of the guide.
          oneOf:
            - type: 'null'
            - description: The recipient of the guide.
              properties:
                id:
                  description: Unique identifier for the recipient.
                  type: string
              type: object
      required:
        - guides
      title: GuidesResponse
      type: object
    MessageInAppFeedContentBlock:
      description: A block in a message in an app feed.
      example:
        content: This is a message in an app feed
        name: body
        rendered: <p>This is a message in an app feed</p>
        type: markdown
      properties:
        content:
          description: The content of the block in a message in an app feed.
          nullable: false
          type: string
        name:
          description: The name of the block in a message in an app feed.
          nullable: false
          type: string
        rendered:
          description: The rendered HTML version of the content.
          nullable: false
          type: string
        type:
          description: The type of block in a message in an app feed.
          enum:
            - markdown
            - text
          nullable: false
          type: string
      required:
        - type
        - name
        - rendered
        - content
      title: MessageInAppFeedContentBlock
      type: object
    ListMessagesResponse:
      description: A paginated list of messages.
      example:
        entries:
          - actors:
              - user_123
            archived_at: null
            channel_id: 123e4567-e89b-12d3-a456-426614174000
            clicked_at: null
            data:
              foo: bar
            engagement_statuses:
              - read
              - seen
            id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
            inserted_at: '2021-01-01T00:00:00Z'
            interacted_at: null
            link_clicked_at: null
            metadata:
              external_id: 123e4567-e89b-12d3-a456-426614174000
            read_at: null
            recipient: user_123
            scheduled_at: null
            seen_at: null
            source:
              __typename: NotificationSource
              categories:
                - collaboration
              key: comment-created
              version_id: 123e4567-e89b-12d3-a456-426614174000
            status: sent
            tenant: tenant_123
            updated_at: '2021-01-01T00:00:00Z'
            workflow: comment-created
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of messages.
          items:
            $ref: '#/components/schemas/Message'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      required:
        - entries
        - page_info
      title: ListMessagesResponse
      type: object
    MergeUserRequest:
      description: A set of parameters to merge one user into another.
      example:
        from_user_id: user_1
      properties:
        from_user_id:
          description: The user ID to merge from.
          type: string
      required:
        - from_user_id
      title: MergeUserRequest
      type: object
    DiscordIncomingWebhookConnection:
      description: Discord incoming webhook connection.
      example:
        incoming_webhook:
          url: https://example.com/webhook
      properties:
        incoming_webhook:
          description: Discord incoming webhook object.
          properties:
            url:
              description: Incoming webhook URL.
              example: https://example.com/webhook
              type: string
          required:
            - url
          type: object
      required:
        - incoming_webhook
      title: DiscordIncomingWebhookConnection
      type: object
    User:
      additionalProperties: true
      description: A user who can receive notifications in Knock. They are always referenced by your internal identifier.
      example:
        __typename: User
        created_at: null
        email: jane@ingen.net
        id: jane
        name: Jane Doe
        updated_at: '2024-05-22T12:00:00Z'
      properties:
        __typename:
          description: The typename of the schema.
          example: User
          type: string
        avatar:
          description: URL to the user's avatar image.
          nullable: true
          type: string
        created_at:
          description: The creation date of the user from your system.
          format: date-time
          nullable: true
          type: string
        email:
          description: The email address of the user.
          nullable: true
          type: string
        id:
          description: The ID for the user that you set when identifying them in Knock.
          type: string
        name:
          description: Display name of the user.
          nullable: true
          type: string
        phone_number:
          description: Phone number of the user.
          nullable: true
          type: string
        timezone:
          description: Timezone of the user.
          nullable: true
          type: string
        updated_at:
          description: The timestamp when the resource was last updated.
          format: date-time
          type: string
      required:
        - __typename
        - id
        - updated_at
      title: User
      type: object
    UpdateSchedulesRequest:
      description: A request to update a schedule.
      example:
        actor: null
        data:
          key: value
        ending_at: null
        repeats:
          - __typename: ScheduleRepeat
            day_of_month: null
            days:
              - mon
              - tue
              - wed
              - thu
              - fri
              - sat
              - sun
            frequency: daily
            hours: null
            interval: 1
            minutes: null
        schedule_ids:
          - 123e4567-e89b-12d3-a456-426614174000
        scheduled_at: null
        tenant: acme_corp
      properties:
        actor:
          description: >-
            A map of properties describing a user or an object to identify in Knock and mark as who or what
            performed the action.
          oneOf:
            - $ref: '#/components/schemas/RecipientRequest'
            - nullable: true
        data:
          additionalProperties: true
          description: An optional map of data to pass into the workflow execution.
          nullable: true
          type: object
        ending_at:
          description: The ending date and time for the schedule.
          format: date-time
          nullable: true
          type: string
        repeats:
          description: The repeat rule for the schedule.
          items:
            $ref: '#/components/schemas/ScheduleRepeatRule'
          type: array
        schedule_ids:
          description: A list of schedule IDs.
          items:
            description: Unique identifier for the schedule.
            format: uuid
            type: string
          type: array
        scheduled_at:
          description: The starting date and time for the schedule.
          format: date-time
          nullable: true
          type: string
        tenant:
          anyOf:
            - $ref: '#/components/schemas/InlineTenantRequest'
            - nullable: true
          description: >-
            The tenant to trigger the workflow for. Triggering with a tenant will use any tenant-level
            overrides associated with the tenant object, and all messages produced from workflow runs will be
            tagged with the tenant.
      required:
        - schedule_ids
      title: UpdateSchedulesRequest
      type: object
    AudienceMember:
      description: An audience member.
      example:
        __typename: AudienceMember
        added_at: '2021-01-01T00:00:00Z'
        tenant: acme_corp
        user:
          __typename: User
          created_at: null
          email: jane@ingen.net
          id: jane
          name: Jane Doe
          updated_at: '2024-05-22T12:00:00Z'
        user_id: user_123
      properties:
        __typename:
          description: The typename of the schema.
          example: AudienceMember
          type: string
        added_at:
          description: Timestamp when the resource was created.
          example: '2021-01-01T00:00:00Z'
          format: date-time
          type: string
        tenant:
          description: The unique identifier for the tenant.
          example: acme_corp
          nullable: true
          type: string
        user:
          $ref: '#/components/schemas/User'
        user_id:
          description: The ID for the user that you set when identifying them in Knock.
          example: user_123
          type: string
      required:
        - __typename
        - added_at
        - user_id
        - user
      title: AudienceMember
      type: object
    MessageSmsContent:
      description: The content of an SMS message.
      example:
        __typename: MessageSmsContent
        body: Hello, world!
        to: '+15551234567'
      properties:
        __typename:
          description: The typename of the schema.
          example: MessageSmsContent
          nullable: false
          type: string
        body:
          description: The content body of the SMS message.
          nullable: false
          type: string
        to:
          description: The phone number the SMS was sent to.
          nullable: false
          type: string
      required:
        - __typename
        - to
        - body
      title: MessageSmsContent
      type: object
    PreferenceSetCategories:
      additionalProperties:
        $ref: '#/components/schemas/PreferenceSetWorkflowCategorySetting'
      description: An object where the key is the category and the values are the preference settings for that category.
      example:
        marketing:
          channel_types:
            email: false
      title: PreferenceSetCategories
      type: object
    PreferenceSetWorkflows:
      additionalProperties:
        $ref: '#/components/schemas/PreferenceSetWorkflowCategorySetting'
      description: >-
        An object where the key is the workflow key and the values are the preference settings for that
        workflow.
      example:
        dinosaurs-loose:
          channel_types:
            email: false
      title: PreferenceSetWorkflows
      type: object
    SlackChannelData:
      description: Slack channel data
      example:
        connections:
          - access_token: xoxb-1234567890
            channel_id: C01234567890
            user_id: U01234567890
        token:
          access_token: xoxb-1234567890
      properties:
        connections:
          description: List of Slack channel connections.
          items:
            description: A Slack connection, either an access token or an incoming webhook
            nullable: false
            oneOf:
              - $ref: '#/components/schemas/SlackTokenConnection'
              - $ref: '#/components/schemas/SlackIncomingWebhookConnection'
            type: object
          nullable: false
          type: array
        token:
          description: A Slack connection token.
          example:
            access_token: xoxb-1234567890
          nullable: true
          properties:
            access_token:
              description: A Slack access token.
              example: xoxb-1234567890
              nullable: true
              type: string
          required:
            - access_token
          title: SlackChannelDataTokenObject
          type: object
      title: SlackChannelData
      type: object
    BulkUpdateMessagesForChannelRequest:
      description: A request to bulk update messages for a specific channel.
      example:
        archived: include
        delivery_status: delivered
        engagement_status: seen
        has_tenant: true
        newer_than: '2024-01-01T00:00:00Z'
        older_than: '2024-01-01T00:00:00Z'
        recipient_ids:
          - recipient1
          - recipient2
        tenants:
          - tenant1
          - tenant2
        trigger_data: '{"key":"value"}'
        workflows:
          - workflow1
          - workflow2
      properties:
        archived:
          description: The archived status to filter messages by.
          enum:
            - exclude
            - include
            - only
          type: string
        delivery_status:
          description: The delivery status to filter messages by.
          enum:
            - queued
            - sent
            - delivered
            - delivery_attempted
            - undelivered
            - not_sent
            - bounced
          type: string
        engagement_status:
          description: The engagement status to filter messages by.
          enum:
            - seen
            - unseen
            - read
            - unread
            - archived
            - unarchived
            - link_clicked
            - interacted
          type: string
        has_tenant:
          description: Whether to include only messages that have a tenant or not.
          type: boolean
        newer_than:
          description: The timestamp to filter messages by. Only include messages created after this timestamp.
          format: date-time
          type: string
        older_than:
          description: The timestamp to filter messages by. Only include messages created before this timestamp.
          format: date-time
          type: string
        recipient_gids:
          description: The recipient GIDs to filter messages by.
          items:
            type: string
          type: array
        recipient_ids:
          description: The recipient IDs to filter messages by.
          items:
            type: string
          type: array
        tenants:
          description: The tenant IDs to filter messages by.
          items:
            type: string
          type: array
        trigger_data:
          description: The trigger data to filter messages by. Must be a valid JSON object.
          type: string
        workflows:
          description: The workflow keys to filter messages by.
          items:
            type: string
          type: array
      title: BulkUpdateMessagesForChannelRequest
      type: object
    EmptyContentResponse:
      description: An empty response.
      example: ''
      title: EmptyContentResponse
      type: string
    BatchListMessagesResponse:
      description: The list of messages that were updated
      example:
        - actors:
            - user_123
          archived_at: null
          channel_id: 123e4567-e89b-12d3-a456-426614174000
          clicked_at: null
          data:
            foo: bar
          engagement_statuses:
            - read
            - seen
          id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          inserted_at: '2021-01-01T00:00:00Z'
          interacted_at: null
          link_clicked_at: null
          metadata:
            external_id: 123e4567-e89b-12d3-a456-426614174000
          read_at: null
          recipient: user_123
          scheduled_at: null
          seen_at: null
          source:
            __typename: NotificationSource
            categories:
              - collaboration
            key: comment-created
            version_id: 123e4567-e89b-12d3-a456-426614174000
          status: sent
          tenant: tenant_123
          updated_at: '2021-01-01T00:00:00Z'
          workflow: comment-created
      items:
        $ref: '#/components/schemas/Message'
      title: BatchListMessagesResponse
      type: array
    Activity:
      description: An activity associated with a workflow run.
      example:
        __typename: Activity
        actor: null
        data:
          foo: bar
        id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
        inserted_at: '2024-01-01T00:00:00Z'
        recipient:
          __typename: User
          avatar: null
          created_at: null
          email: jane@ingen.net
          id: jane
          name: Jane Doe
          phone_number: null
          timezone: null
          updated_at: '2024-05-22T12:00:00Z'
        updated_at: '2024-01-01T00:00:00Z'
      properties:
        __typename:
          description: The typename of the schema.
          example: Activity
          type: string
        actor:
          description: The actor who performed the activity.
          oneOf:
            - $ref: '#/components/schemas/Recipient'
            - nullable: true
          type: object
        data:
          additionalProperties: true
          description: The data associated with the activity.
          nullable: true
          type: object
        id:
          description: Unique identifier for the activity.
          example: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
          type: string
        inserted_at:
          description: Timestamp when the resource was created.
          format: date-time
          type: string
        recipient:
          $ref: '#/components/schemas/Recipient'
        updated_at:
          description: The timestamp when the resource was last updated.
          format: date-time
          type: string
      title: Activity
      type: object
    InlineIdentifyUserRequest:
      additionalProperties: true
      description: >-
        A set of parameters to inline-identify a user with. Inline identifying the user will ensure that the
        user is available before the request is executed in Knock. It will perform an upsert for the user
        you're supplying, replacing any properties specified.
      example:
        email: jane@ingen.net
        id: user_1
        name: Jane Doe
        timezone: America/New_York
      properties:
        channel_data:
          description: A set of channel data for the user. This is a map of channel IDs to channel data.
          oneOf:
            - nullable: true
            - $ref: '#/components/schemas/InlineChannelDataRequest'
        created_at:
          description: The creation date of the user from your system.
          format: date-time
          nullable: true
          type: string
        id:
          description: The ID for the user that you set when identifying them in Knock.
          nullable: false
          type: string
        preferences:
          description: A set of preferences for the user.
          oneOf:
            - nullable: true
            - $ref: '#/components/schemas/InlinePreferenceSetRequest'
      required:
        - id
      title: InlineIdentifyUserRequest
      type: object
    MsTeamsChannelData:
      description: Microsoft Teams channel connection.
      example:
        connections:
          - ms_teams_channel_id: 123e4567-e89b-12d3-a456-426614174000
            ms_teams_team_id: 123e4567-e89b-12d3-a456-426614174000
            ms_teams_tenant_id: null
            ms_teams_user_id: null
        ms_teams_tenant_id: null
      properties:
        connections:
          description: List of Microsoft Teams connections.
          items:
            oneOf:
              - $ref: '#/components/schemas/MsTeamsTokenConnection'
              - $ref: '#/components/schemas/MsTeamsIncomingWebhookConnection'
            type: object
          nullable: false
          type: array
        ms_teams_tenant_id:
          description: Microsoft Teams tenant ID.
          example: 123e4567-e89b-12d3-a456-426614174000
          format: uuid
          nullable: true
          type: string
      required:
        - connections
      title: MsTeamsChannelData
      type: object
    OneSignalChannelData:
      description: OneSignal channel data.
      example:
        player_ids:
          - 123e4567-e89b-12d3-a456-426614174000
      properties:
        player_ids:
          description: A list of OneSignal player IDs.
          example:
            - 123e4567-e89b-12d3-a456-426614174000
          items:
            description: OneSignal player ID.
            format: uuid
            nullable: false
            type: string
          nullable: false
          type: array
      required:
        - player_ids
      title: OneSignalChannelData
      type: object
    SlackIncomingWebhookConnection:
      description: A Slack connection incoming webhook.
      example:
        url: https://hooks.slack.com/services/T01234567890/B01234567890/1234567890
      properties:
        url:
          description: The URL of the incoming webhook for a Slack connection.
          example: https://hooks.slack.com/services/T01234567890/B01234567890/1234567890
          nullable: false
          type: string
      required:
        - url
      title: SlackIncomingWebhookConnection
      type: object
    PreferenceSetChannelTypeSetting:
      description: A set of settings for a channel type. Currently, this can only be a list of conditions to apply.
      example:
        conditions:
          - argument: US
            operator: equal_to
            variable: recipient.country_code
      properties:
        conditions:
          description: A list of conditions to apply to a channel type.
          items:
            $ref: '#/components/schemas/Condition'
          type: array
      required:
        - conditions
      title: PreferenceSetChannelTypeSetting
      type: object
    UpsertSubscriptionsRequest:
      description: A request to upsert subscriptions for a set of recipients.
      example:
        properties:
          key: value
        recipients:
          - user_1
          - user_2
      properties:
        properties:
          additionalProperties: true
          description: The custom properties associated with the recipients of the subscription.
          nullable: true
          type: object
        recipients:
          description: The recipients of the subscription.
          items:
            $ref: '#/components/schemas/RecipientRequest'
          type: array
      required:
        - recipients
      title: UpsertSubscriptionsRequest
      type: object
    Block:
      description: A block in a message in a chat.
      example:
        content: Hello, world!
        name: greeting
        type: text
      nullable: false
      properties:
        content:
          description: The actual content of the block.
          example: Hello, world!
          nullable: false
          type: string
        name:
          description: The name of the block for identification.
          example: greeting
          nullable: false
          type: string
        type:
          description: The type of block in a message in a chat (text or markdown).
          enum:
            - text
            - markdown
          example: text
          nullable: false
          type: string
      required:
        - type
        - name
        - content
      title: Block
      type: object
    Cancel Request:
      description: A request to cancel a previously triggered workflow.
      example:
        cancellation_key: comment_123
        name: new-comment
        recipients:
          - user_456
      properties:
        cancellation_key:
          description: >-
            The cancellation key provided during the initial notify call. If used in a cancel request, will
            cancel the notification for the recipients specified in the cancel request.
          type: string
        name:
          description: The key of the workflow to cancel.
          type: string
        recipients:
          description: >-
            A list of recipients to cancel the notification for. If omitted, cancels for all recipients
            associated with the cancellation key.
          items:
            $ref: '#/components/schemas/RecipientReference'
          type: array
      required:
        - name
        - cancellation_key
      title: Cancel Request
      type: object
    BulkOperation:
      description: A bulk operation entity.
      example:
        __typename: BulkOperation
        completed_at: null
        error_count: 0
        error_items: []
        estimated_total_rows: 1000
        failed_at: null
        id: 123e4567-e89b-12d3-a456-426614174000
        inserted_at: '2024-05-22T12:00:00Z'
        name: Bulk operation name
        processed_rows: 0
        started_at: null
        status: processing
        success_count: 0
        updated_at: '2024-05-22T12:00:00Z'
      properties:
        __typename:
          description: The typename of the schema.
          example: BulkOperation
          type: string
        completed_at:
          description: Timestamp when the bulk operation was completed.
          format: date-time
          nullable: true
          type: string
        error_count:
          description: The number of failed operations.
          example: 0
          type: integer
        error_items:
          description: A list of items that failed to be processed.
          items:
            properties:
              collection:
                description: The collection this object belongs to.
                nullable: true
                type: string
              id:
                description: Unique identifier for the object.
                type: string
            required:
              - id
            type: object
          type: array
        estimated_total_rows:
          description: The estimated total number of rows to process.
          example: 1000
          type: integer
        failed_at:
          description: Timestamp when the bulk operation failed.
          format: date-time
          nullable: true
          type: string
        id:
          description: Unique identifier for the bulk operation.
          format: uuid
          type: string
        inserted_at:
          description: Timestamp when the resource was created.
          format: date-time
          type: string
        name:
          description: The name of the bulk operation.
          example: Bulk operation name
          type: string
        processed_rows:
          description: The number of rows processed so far.
          example: 0
          type: integer
        started_at:
          description: Timestamp when the bulk operation was started.
          format: date-time
          nullable: true
          type: string
        status:
          description: The status of the bulk operation.
          enum:
            - queued
            - processing
            - completed
            - failed
          example: queued
          nullable: false
          type: string
        success_count:
          description: The number of successful operations.
          example: 0
          type: integer
        updated_at:
          description: The timestamp when the resource was last updated.
          format: date-time
          type: string
      required:
        - __typename
        - id
        - name
        - status
        - estimated_total_rows
        - processed_rows
        - success_count
        - updated_at
        - inserted_at
      title: BulkOperation
      type: object
    MsTeamsIncomingWebhookConnection:
      description: Microsoft Teams incoming webhook connection.
      example:
        incoming_webhook:
          url: https://example.com/webhook
      properties:
        incoming_webhook:
          description: Microsoft Teams incoming webhook.
          properties:
            url:
              description: Microsoft Teams incoming webhook URL.
              example: https://example.com/webhook
              type: string
          required:
            - url
          type: object
      required:
        - incoming_webhook
      title: MsTeamsIncomingWebhookConnection
      type: object
    Message:
      description: Represents a single message that was generated by a workflow for a given channel.
      example:
        actors:
          - user_123
        archived_at: null
        channel_id: 123e4567-e89b-12d3-a456-426614174000
        clicked_at: null
        data:
          foo: bar
        engagement_statuses:
          - read
          - seen
        id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
        inserted_at: '2021-01-01T00:00:00Z'
        interacted_at: null
        link_clicked_at: null
        metadata:
          external_id: 123e4567-e89b-12d3-a456-426614174000
        read_at: null
        recipient: user_123
        scheduled_at: null
        seen_at: null
        source:
          __typename: NotificationSource
          categories:
            - collaboration
          key: comment-created
          version_id: 123e4567-e89b-12d3-a456-426614174000
        status: sent
        tenant: tenant_123
        updated_at: '2021-01-01T00:00:00Z'
        workflow: comment-created
      properties:
        __typename:
          description: The typename of the schema.
          example: Message
          type: string
        actors:
          description: >-
            One or more actors that are associated with this message. Note: this is a list that can contain up
            to 10 actors if the message is produced from a batch.
          items:
            $ref: '#/components/schemas/RecipientReference'
          type: array
        archived_at:
          description: Timestamp when the message was archived.
          format: date-time
          nullable: true
          type: string
        channel_id:
          description: The id for the channel the message was sent through.
          format: uuid
          type: string
        clicked_at:
          description: Timestamp when the message was clicked.
          format: date-time
          nullable: true
          type: string
        data:
          additionalProperties: true
          description: Data from the activities linked to the message.
          nullable: true
          type: object
        engagement_statuses:
          description: A list of engagement statuses.
          example:
            - read
            - seen
          items:
            description: >-
              An engagement status for a message. Can be one of: read, seen, interacted, link_clicked,
              archived.
            enum:
              - seen
              - read
              - interacted
              - link_clicked
              - archived
            type: string
          type: array
        id:
          description: The unique identifier for the message.
          type: string
        inserted_at:
          description: Timestamp when the resource was created.
          format: date-time
          type: string
        interacted_at:
          description: Timestamp when the message was interacted with.
          format: date-time
          nullable: true
          type: string
        link_clicked_at:
          description: Timestamp when a link in the message was clicked.
          format: date-time
          nullable: true
          type: string
        metadata:
          additionalProperties: true
          description: The metadata associated with the message.
          example:
            external_id: 123e4567-e89b-12d3-a456-426614174000
          nullable: true
          type: object
        read_at:
          description: Timestamp when the message was read.
          format: date-time
          nullable: true
          type: string
        recipient:
          $ref: '#/components/schemas/RecipientReference'
        scheduled_at:
          description: Timestamp when the message was scheduled to be sent.
          format: date-time
          nullable: true
          type: string
        seen_at:
          description: Timestamp when the message was seen.
          format: date-time
          nullable: true
          type: string
        source:
          description: The source that triggered the message.
          example:
            __typename: Guide
            categories:
              - collaboration
            key: comment-created
            version_id: 123e4567-e89b-12d3-a456-426614174000
          properties:
            __typename:
              example: Guide
              type: string
            categories:
              description: The categories associated with the message.
              items:
                type: string
              type: array
            key:
              description: The key of the source that triggered the message.
              type: string
            version_id:
              description: The id of the version of the source that triggered the message.
              format: uuid
              type: string
          required:
            - __typename
            - key
            - version_id
            - categories
          type: object
        status:
          description: The message delivery status.
          enum:
            - queued
            - sent
            - delivered
            - delivery_attempted
            - undelivered
            - not_sent
            - bounced
          example: sent
          type: string
        tenant:
          description: The id for the tenant set for the message.
          nullable: true
          type: string
        updated_at:
          description: The timestamp when the resource was last updated.
          format: date-time
          type: string
        workflow:
          deprecated: true
          description: The key of the workflow that generated the message.
          nullable: true
          type: string
      title: Message
      type: object
    BulkSetTenantsRequest:
      description: A request to set tenants in bulk.
      example:
        tenants:
          - id: tenant_1
            name: Acme Corp, Inc.
      properties:
        tenants:
          description: The tenants to be upserted.
          items:
            $ref: '#/components/schemas/InlineTenantRequest'
          type: array
      required:
        - tenants
      title: BulkSetTenantsRequest
      type: object
    AudienceMemberRequest:
      description: An audience member.
      example:
        tenant: null
        user:
          email: jane@ingen.net
          id: user_1
          name: Jane Doe
          timezone: America/New_York
      properties:
        tenant:
          description: The unique identifier for the tenant.
          example: acme_corp
          nullable: true
          type: string
        user:
          $ref: '#/components/schemas/InlineIdentifyUserRequest'
      required:
        - user
      title: AudienceMemberRequest
      type: object
    RemoveAudienceMembersRequest:
      description: A request to remove a list of audience members.
      example:
        members:
          - tenant: null
            user:
              email: jane@ingen.net
              id: user_1
              name: Jane Doe
              timezone: America/New_York
      properties:
        members:
          description: A list of audience members to remove.
          items:
            $ref: '#/components/schemas/AudienceMemberRequest'
          nullable: false
          type: array
      required:
        - members
      title: RemoveAudienceMembersRequest
      type: object
    SetTenantRequest:
      additionalProperties: true
      description: A tenant to be set in the system. You can supply any additional properties on the tenant object.
      example:
        name: ACME Corp, Inc.
        settings:
          branding:
            icon_url: https://example.com/icon.png
            logo_url: https://example.com/logo.png
            primary_color: '#000000'
            primary_color_contrast: '#FFFFFF'
      properties:
        channel_data:
          description: The channel data for the tenant.
          oneOf:
            - nullable: true
            - $ref: '#/components/schemas/InlineChannelDataRequest'
        preferences:
          description: The preferences for the tenant.
          oneOf:
            - nullable: true
            - $ref: '#/components/schemas/InlinePreferenceSetRequest'
        settings:
          description: The settings for the tenant. Includes branding and preference set.
          properties:
            branding:
              description: The branding for the tenant.
              properties:
                icon_url:
                  description: The icon URL for the tenant.
                  nullable: true
                  type: string
                logo_url:
                  description: The logo URL for the tenant.
                  nullable: true
                  type: string
                primary_color:
                  description: The primary color for the tenant.
                  nullable: true
                  type: string
                primary_color_contrast:
                  description: The primary color contrast for the tenant.
                  nullable: true
                  type: string
              type: object
            preference_set:
              description: The preference set for the tenant. Used to override the default preference set.
              oneOf:
                - nullable: true
                - $ref: '#/components/schemas/PreferenceSetRequest'
          type: object
      title: SetTenantRequest
      type: object
    MessageInAppFeedContent:
      description: The content of an in-app feed message.
      example:
        __typename: MessageInAppFeedContent
        blocks:
          - content: This is a message in an app feed
            name: body
            rendered: <p>This is a message in an app feed</p>
            type: markdown
      nullable: false
      properties:
        __typename:
          description: The typename of the schema.
          example: MessageInAppFeedContent
          nullable: false
          type: string
        blocks:
          description: The blocks of the message in an app feed.
          items:
            description: A block in a message in an app feed.
            nullable: false
            oneOf:
              - $ref: '#/components/schemas/MessageInAppFeedContentBlock'
              - $ref: '#/components/schemas/MessageInAppFeedButtonSetBlock'
            type: object
          nullable: false
          type: array
      required:
        - __typename
        - blocks
      title: MessageInAppFeedContent
      type: object
    DiscordChannelConnection:
      description: Discord channel connection.
      example:
        channel_id: '123456789012345678'
      properties:
        channel_id:
          description: Discord channel ID.
          example: '123456789012345678'
          type: string
      required:
        - channel_id
      title: DiscordChannelConnection
      type: object
    DeleteSubscriptionsRequest:
      description: A request to delete subscriptions for a set of recipients.
      example:
        recipients:
          - id: user_1
      properties:
        recipients:
          description: The recipients of the subscription.
          items:
            $ref: '#/components/schemas/RecipientRequest'
          type: array
      required:
        - recipients
      title: DeleteSubscriptionsRequest
      type: object
    Schedule:
      description: A schedule represents a recurring workflow execution.
      example:
        __typename: Schedule
        actor: null
        data: null
        id: 123e4567-e89b-12d3-a456-426614174000
        inserted_at: '2021-01-01T00:00:00Z'
        last_occurrence_at: null
        next_occurrence_at: null
        recipient:
          __typename: User
          avatar: null
          created_at: null
          email: jane@ingen.net
          id: jane
          name: Jane Doe
          phone_number: null
          timezone: null
          updated_at: '2024-05-22T12:00:00Z'
        repeats:
          - __typename: ScheduleRepeat
            day_of_month: null
            days:
              - mon
              - tue
              - wed
              - thu
              - fri
              - sat
              - sun
            frequency: daily
            hours: null
            interval: 1
            minutes: null
        tenant: null
        updated_at: '2021-01-01T00:00:00Z'
        workflow: workflow_123
      properties:
        __typename:
          description: The typename of the schema.
          example: Schedule
          type: string
        actor:
          description: >-
            A map of properties describing a user or an object to identify in Knock and mark as who or what
            performed the action.
          oneOf:
            - $ref: '#/components/schemas/Recipient'
            - nullable: true
        data:
          additionalProperties: true
          description: An optional map of data to pass into the workflow execution.
          nullable: true
          type: object
        id:
          description: Unique identifier for the schedule.
          format: uuid
          type: string
        inserted_at:
          description: Timestamp when the resource was created.
          format: date-time
          type: string
        last_occurrence_at:
          description: The last occurrence of the schedule.
          format: date-time
          nullable: true
          type: string
        next_occurrence_at:
          description: The next occurrence of the schedule.
          format: date-time
          nullable: true
          type: string
        recipient:
          $ref: '#/components/schemas/Recipient'
        repeats:
          description: The repeat rule for the schedule.
          items:
            $ref: '#/components/schemas/ScheduleRepeatRule'
          type: array
        tenant:
          description: >-
            The tenant to trigger the workflow for. Triggering with a tenant will use any tenant-level
            overrides associated with the tenant object, and all messages produced from workflow runs will be
            tagged with the tenant.
          nullable: true
          type: string
        updated_at:
          description: The timestamp when the resource was last updated.
          format: date-time
          type: string
        workflow:
          description: The workflow the schedule is applied to.
          type: string
      required:
        - id
        - workflow
        - recipient
        - repeats
        - inserted_at
        - updated_at
      title: Schedule
      type: object
    SchedulesResponse:
      description: A list of schedules.
      example:
        - __typename: Schedule
          actor: null
          data: null
          id: 123e4567-e89b-12d3-a456-426614174000
          inserted_at: '2021-01-01T00:00:00Z'
          last_occurrence_at: null
          next_occurrence_at: null
          recipient:
            __typename: User
            avatar: null
            created_at: null
            email: jane@ingen.net
            id: jane
            name: Jane Doe
            phone_number: null
            timezone: null
            updated_at: '2024-05-22T12:00:00Z'
          repeats:
            - __typename: ScheduleRepeat
              day_of_month: null
              days:
                - mon
                - tue
                - wed
                - thu
                - fri
                - sat
                - sun
              frequency: daily
              hours: null
              interval: 1
              minutes: null
          tenant: null
          updated_at: '2021-01-01T00:00:00Z'
          workflow: workflow_123
      items:
        $ref: '#/components/schemas/Schedule'
      title: SchedulesResponse
      type: array
    PreferenceSetRequest:
      description: A request to set a preference set for a recipient.
      example:
        categories:
          marketing: false
          transactional:
            channel_types:
              email: false
        channel_types:
          email: true
        workflows:
          dinosaurs-loose:
            channel_types:
              email: false
      properties:
        categories:
          anyOf:
            - additionalProperties:
                $ref: '#/components/schemas/PreferenceSetWorkflowCategorySetting'
              description: >-
                An object where the key is the category and the values are the preference settings for that
                category.
              example:
                marketing:
                  channel_types:
                    email: false
              title: PreferenceSetRequestCategories
              type: object
            - nullable: true
          description: >-
            An object where the key is the category and the values are the preference settings for that
            category.
        channel_types:
          anyOf:
            - $ref: '#/components/schemas/PreferenceSetChannelTypes'
            - nullable: true
          description: A map of preference set channel types.
        workflows:
          anyOf:
            - additionalProperties:
                $ref: '#/components/schemas/PreferenceSetWorkflowCategorySetting'
              description: >-
                An object where the key is the workflow key and the values are the preference settings for
                that workflow.
              example:
                dinosaurs-loose:
                  channel_types:
                    email: false
              title: PreferenceSetRequestWorkflows
              type: object
            - nullable: true
          description: >-
            An object where the key is the workflow key and the values are the preference settings for that
            workflow.
      title: PreferenceSetRequest
      type: object
    TeamsForMsTeamsProviderResponse:
      description: The response from a Microsoft Teams provider request, containing a list of teams.
      example:
        ms_teams_teams:
          - displayName: Engineering Team
            id: team-id-1
        skip_token: token-for-next-page
      properties:
        ms_teams_teams:
          description: List of Microsoft Teams teams.
          items:
            properties:
              description:
                description: Microsoft Teams team description.
                nullable: true
                type: string
              displayName:
                description: Microsoft Teams team display name.
                nullable: false
                type: string
              id:
                description: Microsoft Teams team ID.
                nullable: false
                type: string
            required:
              - id
              - displayName
            type: object
          type: array
        skip_token:
          description: >-
            [OData param](https://learn.microsoft.com/en-us/graph/query-parameters) passed to the Microsoft
            Graph API to retrieve the next page of results.
          nullable: true
          type: string
      required:
        - ms_teams_teams
        - skip_token
      title: TeamsForMsTeamsProviderResponse
      type: object
    ListMessageEventsResponse:
      description: A paginated list of message events.
      example:
        entries:
          - __typename: MessageEvent
            data: null
            id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
            inserted_at: '2021-01-01T00:00:00Z'
            recipient: user_123
            type: message.sent
        page_info:
          __typename: PageInfo
          after: null
          before: null
          page_size: 25
      properties:
        entries:
          description: A list of message events.
          items:
            $ref: '#/components/schemas/MessageEvent'
          type: array
        page_info:
          $ref: '#/components/schemas/PageInfo'
      required:
        - entries
        - page_info
      title: ListMessageEventsResponse
      type: object
    SubscriptionsResponse:
      description: A response containing a list of subscriptions.
      example:
        - __typename: Subscription
          inserted_at: '2021-01-01T00:00:00Z'
          object:
            __typename: Object
            collection: projects
            created_at: null
            id: project_1
            name: My first project
            updated_at: '2024-05-22T12:00:00Z'
          recipient:
            __typename: User
            avatar: null
            created_at: null
            email: jane@ingen.net
            id: jane
            name: Jane Doe
            phone_number: null
            timezone: null
            updated_at: '2024-05-22T12:00:00Z'
          updated_at: '2021-01-01T00:00:00Z'
      items:
        $ref: '#/components/schemas/Subscription'
      title: SubscriptionsResponse
      type: array
    ChannelsForSlackProviderResponse:
      description: The response from a Slack provider request, containing a list of channels.
      example:
        next_cursor: null
        slack_channels:
          - context_team_id: T01234567890
            id: C01234567890
            is_im: false
            is_private: false
            name: general
      properties:
        next_cursor:
          description: >-
            Paginate through collections of data by setting the cursor parameter to a next_cursor attribute
            returned by a previous request's response_metadata. Default value fetches the first "page" of the
            collection.
          nullable: true
          type: string
        slack_channels:
          description: List of Slack channels.
          items:
            description: A Slack channel.
            properties:
              context_team_id:
                description: The team ID that the Slack channel belongs to.
                nullable: false
                type: string
              id:
                description: A Slack channel ID from the Slack provider.
                nullable: false
                type: string
              is_im:
                description: Whether the Slack channel is an IM channel.
                nullable: false
                type: boolean
              is_private:
                description: Whether the Slack channel is private.
                nullable: false
                type: boolean
              name:
                description: Slack channel name.
                nullable: false
                type: string
            required:
              - id
              - name
              - is_private
              - is_im
              - context_team_id
            type: object
          type: array
      required:
        - slack_channels
        - next_cursor
      title: ChannelsForSlackProviderResponse
      type: object
    Condition:
      description: A condition to be evaluated.
      example:
        argument: some_property
        operator: equal_to
        variable: recipient.property
      properties:
        argument:
          description: The argument value to compare against in the condition.
          example: some_property
          nullable: true
          type: string
        operator:
          description: The operator to use in the condition evaluation.
          enum:
            - equal_to
            - not_equal_to
            - greater_than
            - less_than
            - greater_than_or_equal_to
            - less_than_or_equal_to
            - contains
            - not_contains
            - empty
            - not_empty
            - contains_all
            - is_timestamp
            - is_not_timestamp
            - is_timestamp_after
            - is_timestamp_before
            - is_timestamp_between
            - is_audience_member
            - is_not_audience_member
          example: equal_to
          type: string
        variable:
          description: The variable to be evaluated in the condition.
          example: recipient.property
          type: string
      required:
        - variable
        - operator
        - argument
      title: Condition
      type: object
    CancelWorkflowRequest:
      description: A request to cancel a previously triggered workflow.
      example:
        cancellation_key: cancel-workflow-123
        recipients:
          - jhammond
      properties:
        cancellation_key:
          description: >-
            The cancellation key provided during the initial notify call. If used in a cancel request, will
            cancel the notification for the recipients specified in the cancel request.
          type: string
        recipients:
          description: >-
            A list of recipients to cancel the notification for. If omitted, cancels for all recipients
            associated with the cancellation key.
          items:
            description: A recipient of a notification, which is either a user or an object.
            type: string
          nullable: true
          type: array
      required:
        - cancellation_key
      title: CancelWorkflowRequest
      type: object
    ChannelDataRequest:
      description: A request to set channel data for a type of channel.
      example:
        data:
          __typename: PushChannelData
          tokens:
            - push_token_1
      properties:
        data:
          description: Channel data for a given channel type.
          discriminator:
            mapping:
              DiscordChannelData: '#/components/schemas/DiscordChannelData'
              MsTeamsChannelData: '#/components/schemas/MsTeamsChannelData'
              OneSignalChannelData: '#/components/schemas/OneSignalChannelData'
              PushChannelData: '#/components/schemas/PushChannelData'
              SlackChannelData: '#/components/schemas/SlackChannelData'
            propertyName: __typename
          nullable: false
          oneOf:
            - $ref: '#/components/schemas/PushChannelData'
            - $ref: '#/components/schemas/OneSignalChannelData'
            - $ref: '#/components/schemas/SlackChannelData'
            - $ref: '#/components/schemas/MsTeamsChannelData'
            - $ref: '#/components/schemas/DiscordChannelData'
          type: object
      required:
        - data
      title: ChannelDataRequest
      type: object
    MessageDeliveryLogRequest:
      description: A message delivery log request.
      example:
        body:
          html_content: <html></html>
        headers:
          Content-Type: application/json
        host: localhost
        method: GET
        path: /
        query: '?foo=bar'
      properties:
        body:
          description: The body content that was sent with the request.
          oneOf:
            - type: string
            - additionalProperties: true
              type: object
          type: object
        headers:
          additionalProperties: true
          description: The headers that were sent with the request.
          nullable: true
          type: object
        host:
          description: The host to which the request was sent.
          example: localhost
          nullable: false
          type: string
        method:
          description: The HTTP method used for the request.
          enum:
            - GET
            - POST
            - PUT
            - DELETE
            - PATCH
          example: GET
          nullable: false
          type: string
        path:
          description: The path of the URL that was requested.
          example: /
          nullable: false
          type: string
        query:
          description: The query string of the URL that was requested.
          example: '?foo=bar'
          nullable: true
          type: string
      title: MessageDeliveryLogRequest
      type: object
  securitySchemes:
    BearerAuth:
      bearerFormat: JWT
      scheme: bearer
      type: http
info:
  title: Knock API
  version: '1.0'
openapi: 3.0.0
paths:
  /v1/objects/{collection}/{object_id}/preferences/{preference_set_id}/categories:
    put:
      callbacks: {}
      deprecated: true
      description: Updates the category preferences for an object's preference set.
      operationId: updateObjectPreferenceCategories
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update categories in preference set
      tags:
        - Objects
        - Preferences
  /v1/users/{user_id}/preferences/{preference_set_id}:
    get:
      callbacks: {}
      description: Retrieves a specific preference set for a user identified by the preference set ID.
      operationId: getUserPreferenceSet
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: Unique identifier for the preference set.
          in: path
          name: preference_set_id
          required: true
          schema:
            default: default
            example: default
            type: string
        - description: The unique identifier for the tenant.
          in: query
          name: tenant
          required: false
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Get preference set
      tags:
        - Users
        - Preferences
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const preferenceSet = await client.users.getPreferences('user_id', 'default');

            console.log(preferenceSet.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          preference_set = client.users.get_preferences(
              user_id="user_id",
              preference_set_id="default",
          )
          print(preference_set.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            preferenceSet, err := client.Users.GetPreferences(
              context.TODO(),
              "user_id",
              "default",
              knock.UserGetPreferencesParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", preferenceSet.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.recipients.preferences.PreferenceSet;
          import app.knock.api.models.users.UserGetPreferencesParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserGetPreferencesParams params = UserGetPreferencesParams.builder()
                      .userId("user_id")
                      .preferenceSetId("default")
                      .build();
                  PreferenceSet preferenceSet = client.users().getPreferences(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          preference_set = knock.users.get_preferences("user_id", "default")

          puts(preference_set)
    put:
      callbacks: {}
      description: >-
        Updates a complete preference set for a user. This is a destructive operation that will replace the
        existing preference set for the user.
      operationId: updateUserPreferenceSet
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: Unique identifier for the preference set.
          in: path
          name: preference_set_id
          required: true
          schema:
            default: default
            example: default
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PreferenceSetRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update preference set
      tags:
        - Users
        - Preferences
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const preferenceSet = await client.users.setPreferences('user_id', 'default');

            console.log(preferenceSet.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          preference_set = client.users.set_preferences(
              user_id="user_id",
              preference_set_id="default",
          )
          print(preference_set.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            preferenceSet, err := client.Users.SetPreferences(
              context.TODO(),
              "user_id",
              "default",
              knock.UserSetPreferencesParams{
                PreferenceSetRequest: knock.PreferenceSetRequestParam{

                },
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", preferenceSet.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.recipients.preferences.PreferenceSet;
          import app.knock.api.models.recipients.preferences.PreferenceSetRequest;
          import app.knock.api.models.users.UserSetPreferencesParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserSetPreferencesParams params = UserSetPreferencesParams.builder()
                      .userId("user_id")
                      .preferenceSetId("default")
                      .preferenceSetRequest(PreferenceSetRequest.builder().build())
                      .build();
                  PreferenceSet preferenceSet = client.users().setPreferences(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          preference_set = knock.users.set_preferences("user_id", "default")

          puts(preference_set)
  /v1/integrations/census/custom-destination:
    post:
      callbacks: {}
      description: Processes a Census custom destination RPC request.
      operationId: processCensusRpcRequest
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              properties:
                id:
                  description: The unique identifier for the RPC request.
                  type: string
                jsonrpc:
                  description: The JSON-RPC version.
                  type: string
                method:
                  description: The method name to execute.
                  type: string
                params:
                  description: The parameters for the method.
                  type: object
              required:
                - id
                - method
                - jsonrpc
              type: object
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                properties:
                  id:
                    description: The request ID.
                    type: string
                  result:
                    description: The result of the RPC call.
                    type: object
                type: object
          description: OK
      summary: Process a Census RPC request
      tags:
        - Integrations
  /v1/objects/{collection}/{object_id}/messages:
    get:
      callbacks: {}
      description: >-
        Returns a paginated list of messages for a specific object in the given collection. Allows filtering
        by message status and provides various sorting options.
      operationId: listMessagesForObject
      parameters:
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
        - description: Limits the results to items with the corresponding tenant, or where the tenant is empty.
          example: tenant_123
          in: query
          name: tenant
          required: false
          schema:
            type: string
        - description: Limits the results to items with the corresponding channel id.
          example: 123e4567-e89b-12d3-a456-426614174000
          in: query
          name: channel_id
          required: false
          schema:
            type: string
        - description: One or more delivery statuses. Limits results to messages with the given delivery status(es).
          example:
            - delivered
          in: query
          name: status[]
          required: false
          schema:
            items:
              enum:
                - queued
                - sent
                - delivered
                - delivery_attempted
                - undelivered
                - not_sent
                - bounced
              type: string
            type: array
        - description: One or more engagement statuses. Limits results to messages with the given engagement status(es).
          example:
            - unread
          in: query
          name: engagement_status[]
          required: false
          schema:
            items:
              enum:
                - seen
                - read
                - interacted
                - link_clicked
                - archived
              type: string
            type: array
        - description: >-
            Limits the results to only the message ids given (max 50). Note: when using this option, the
            results will be subject to any other filters applied to the query.
          example:
            - 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: query
          name: message_ids[]
          required: false
          schema:
            items:
              type: string
            type: array
        - description: Limits the results to only items related to any of the provided categories.
          example:
            - workflow_123
          in: query
          name: workflow_categories[]
          required: false
          schema:
            items:
              type: string
            type: array
        - description: Key of the source that triggered the message to limit results to.
          example: comment-created
          in: query
          name: source
          required: false
          schema:
            type: string
        - description: Limits the results to messages triggered by the top-level workflow run ID.
          example: 123e4567-e89b-12d3-a456-426614174000
          in: query
          name: workflow_run_id
          required: false
          schema:
            format: uuid
            type: string
        - description: Limits the results to messages for a specific recipient's workflow run.
          example: 123e4567-e89b-12d3-a456-426614174000
          in: query
          name: workflow_recipient_run_id
          required: false
          schema:
            format: uuid
            type: string
        - description: Limits the results to only items that were generated with the given data.
          example: '{"comment_id": "123"}'
          in: query
          name: trigger_data
          required: false
          schema:
            type: string
        - description: The collection this object belongs to.
          example: projects
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: Unique identifier for the object.
          example: project-123
          in: path
          name: object_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListMessagesResponse'
          description: OK
      summary: List messages
      tags:
        - Messages
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const message of client.objects.listMessages('projects', 'project-123')) {
              console.log(message.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.objects.list_messages(
              collection="projects",
              object_id="project-123",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Objects.ListMessages(
              context.TODO(),
              "projects",
              "project-123",
              knock.ObjectListMessagesParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectListMessagesPage;
          import app.knock.api.models.objects.ObjectListMessagesParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectListMessagesParams params = ObjectListMessagesParams.builder()
                      .collection("projects")
                      .objectId("project-123")
                      .build();
                  ObjectListMessagesPage page = client.objects().listMessages(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.objects.list_messages("collection", "object_id")

          puts(page)
  /v1/bulk_operations/{id}:
    get:
      callbacks: {}
      description: Retrieves a bulk operation (if it exists) and displays the current state of it.
      operationId: getBulkOperation
      parameters:
        - description: The ID of the bulk operation to retrieve.
          in: path
          name: id
          required: true
          schema:
            format: uuid
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Get bulk operation
      tags:
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.bulkOperations.get('182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e');

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.bulk_operations.get(
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.BulkOperations.Get(context.TODO(), "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.bulkoperations.BulkOperationGetParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkOperationGetParams params = BulkOperationGetParams.builder()
                      .id("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .build();
                  BulkOperation bulkOperation = client.bulkOperations().get(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          bulk_operation = knock.bulk_operations.get("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")

          puts(bulk_operation)
  /v1/users/{user_id}/subscriptions:
    get:
      callbacks: {}
      description: >-
        Retrieves a paginated list of subscriptions for a specific user. Allows filtering by objects and
        includes optional preference data.
      operationId: listSubscriptionsForUser
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: Associated resources to include in the response.
          in: query
          name: include[]
          required: false
          schema:
            items:
              enum:
                - preferences
              type: string
            type: array
        - description: Only return subscriptions for the given recipients.
          in: query
          name: objects[]
          required: false
          schema:
            items:
              $ref: '#/components/schemas/RecipientReference'
            type: array
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListSubscriptionsResponse'
          description: OK
      summary: List subscriptions
      tags:
        - Subscriptions
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const subscription of client.users.listSubscriptions('user_id')) {
              console.log(subscription.__typename);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.users.list_subscriptions(
              user_id="user_id",
          )
          page = page.entries[0]
          print(page._typename)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Users.ListSubscriptions(
              context.TODO(),
              "user_id",
              knock.UserListSubscriptionsParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.UserListSubscriptionsPage;
          import app.knock.api.models.users.UserListSubscriptionsParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserListSubscriptionsParams params = UserListSubscriptionsParams.builder()
                      .userId("user_id")
                      .build();
                  UserListSubscriptionsPage page = client.users().listSubscriptions(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.users.list_subscriptions("user_id")

          puts(page)
  /v1/users/{user_id}:
    delete:
      callbacks: {}
      description: Permanently delete a user and all associated data.
      operationId: deleteUser
      parameters:
        - description: The ID of the user to delete.
          in: path
          name: user_id
          required: true
          schema:
            type: string
      responses:
        '204':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EmptyContentResponse'
          description: No Content
      summary: Delete user
      tags:
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const user = await client.users.delete('user_id');

            console.log(user);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          user = client.users.delete(
              "user_id",
          )
          print(user)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            user, err := client.Users.Delete(context.TODO(), "user_id")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", user)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.UserDeleteParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserDeleteParams params = UserDeleteParams.builder()
                      .userId("user_id")
                      .build();
                  String user = client.users().delete(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          user = knock.users.delete("user_id")

          puts(user)
    get:
      callbacks: {}
      description: Retrieve a specific user by their ID.
      operationId: getUser
      parameters:
        - description: The ID of the user to retrieve.
          in: path
          name: user_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
          description: OK
      summary: Get user
      tags:
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const user = await client.users.get('user_id');

            console.log(user.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          user = client.users.get(
              "user_id",
          )
          print(user.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            user, err := client.Users.Get(context.TODO(), "user_id")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", user.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.User;
          import app.knock.api.models.users.UserGetParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserGetParams params = UserGetParams.builder()
                      .userId("user_id")
                      .build();
                  User user = client.users().get(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          user = knock.users.get("user_id")

          puts(user)
    put:
      callbacks: {}
      description: Create or update a user with the provided identification data.
      operationId: identifyUser
      parameters:
        - description: The ID of the user to identify.
          in: path
          name: user_id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IdentifyUserRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
          description: OK
      summary: Identify user
      tags:
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const user = await client.users.update('user_id');

            console.log(user.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          user = client.users.update(
              user_id="user_id",
          )
          print(user.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            user, err := client.Users.Update(
              context.TODO(),
              "user_id",
              knock.UserUpdateParams{
                IdentifyUserRequest: knock.IdentifyUserRequestParam{

                },
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", user.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.IdentifyUserRequest;
          import app.knock.api.models.users.User;
          import app.knock.api.models.users.UserUpdateParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserUpdateParams params = UserUpdateParams.builder()
                      .userId("user_id")
                      .identifyUserRequest(IdentifyUserRequest.builder().build())
                      .build();
                  User user = client.users().update(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          user = knock.users.update("user_id")

          puts(user)
  /v1/messages/{message_id}/delivery_logs:
    get:
      callbacks: {}
      description: Returns a paginated list of delivery logs for the specified message.
      operationId: listMessageDeliveryLogs
      parameters:
        - description: The ID of the message to fetch delivery logs for.
          in: path
          name: message_id
          required: true
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListMessageDeliveryLogsResponse'
          description: OK
      summary: List delivery logs
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const messageDeliveryLog of client.messages.listDeliveryLogs('message_id')) {
              console.log(messageDeliveryLog.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.messages.list_delivery_logs(
              message_id="message_id",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Messages.ListDeliveryLogs(
              context.TODO(),
              "message_id",
              knock.MessageListDeliveryLogsParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.MessageListDeliveryLogsPage;
          import app.knock.api.models.messages.MessageListDeliveryLogsParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageListDeliveryLogsParams params = MessageListDeliveryLogsParams.builder()
                      .messageId("message_id")
                      .build();
                  MessageListDeliveryLogsPage page = client.messages().listDeliveryLogs(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.messages.list_delivery_logs("message_id")

          puts(page)
  /v1/objects/{collection}/{object_id}/schedules:
    get:
      callbacks: {}
      description: Returns a paginated list of schedules for an object.
      operationId: listObjectSchedules
      parameters:
        - description: The ID of the object to list schedules for.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection of the object to list schedules for.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: Filter schedules by tenant id.
          in: query
          name: tenant
          required: false
          schema:
            type: string
        - description: Filter schedules by workflow id.
          in: query
          name: workflow
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListSchedulesResponse'
          description: OK
      summary: List schedules
      tags:
        - Schedules
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const schedule of client.objects.listSchedules('collection', 'object_id')) {
              console.log(schedule.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.objects.list_schedules(
              collection="collection",
              object_id="object_id",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Objects.ListSchedules(
              context.TODO(),
              "collection",
              "object_id",
              knock.ObjectListSchedulesParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectListSchedulesPage;
          import app.knock.api.models.objects.ObjectListSchedulesParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectListSchedulesParams params = ObjectListSchedulesParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .build();
                  ObjectListSchedulesPage page = client.objects().listSchedules(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.objects.list_schedules("collection", "object_id")

          puts(page)
  /v1/messages:
    get:
      callbacks: {}
      description: Returns a paginated list of messages for the current environment.
      operationId: listMessages
      parameters:
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
        - description: Limits the results to items with the corresponding tenant, or where the tenant is empty.
          example: tenant_123
          in: query
          name: tenant
          required: false
          schema:
            type: string
        - description: Limits the results to items with the corresponding channel id.
          example: 123e4567-e89b-12d3-a456-426614174000
          in: query
          name: channel_id
          required: false
          schema:
            type: string
        - description: One or more delivery statuses. Limits results to messages with the given delivery status(es).
          example:
            - delivered
          in: query
          name: status[]
          required: false
          schema:
            items:
              enum:
                - queued
                - sent
                - delivered
                - delivery_attempted
                - undelivered
                - not_sent
                - bounced
              type: string
            type: array
        - description: One or more engagement statuses. Limits results to messages with the given engagement status(es).
          example:
            - unread
          in: query
          name: engagement_status[]
          required: false
          schema:
            items:
              enum:
                - seen
                - read
                - interacted
                - link_clicked
                - archived
              type: string
            type: array
        - description: >-
            Limits the results to only the message ids given (max 50). Note: when using this option, the
            results will be subject to any other filters applied to the query.
          example:
            - 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: query
          name: message_ids[]
          required: false
          schema:
            items:
              type: string
            type: array
        - description: Limits the results to only items related to any of the provided categories.
          example:
            - workflow_123
          in: query
          name: workflow_categories[]
          required: false
          schema:
            items:
              type: string
            type: array
        - description: Key of the source that triggered the message to limit results to.
          example: comment-created
          in: query
          name: source
          required: false
          schema:
            type: string
        - description: Limits the results to messages triggered by the top-level workflow run ID.
          example: 123e4567-e89b-12d3-a456-426614174000
          in: query
          name: workflow_run_id
          required: false
          schema:
            format: uuid
            type: string
        - description: Limits the results to messages for a specific recipient's workflow run.
          example: 123e4567-e89b-12d3-a456-426614174000
          in: query
          name: workflow_recipient_run_id
          required: false
          schema:
            format: uuid
            type: string
        - description: Limits the results to only items that were generated with the given data.
          example: '{"comment_id": "123"}'
          in: query
          name: trigger_data
          required: false
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListMessagesResponse'
          description: OK
      summary: List messages
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const message of client.messages.list()) {
              console.log(message.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.messages.list()
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Messages.List(context.TODO(), knock.MessageListParams{

            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.MessageListPage;
          import app.knock.api.models.messages.MessageListParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageListPage page = client.messages().list();
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.messages.list

          puts(page)
  /v1/messages/{message_id}/unseen:
    delete:
      callbacks: {}
      description: Marks a message as unseen for the current user, reversing the seen state.
      operationId: markMessageUnseen (2)
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Mark message as unseen
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const message = await client.messages.markAsUnseen('1jNaXzB2RZX3LY8wVQnfCKyPnv7');

            console.log(message.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          message = client.messages.mark_as_unseen(
              "message_id",
          )
          print(message.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            message, err := client.Messages.MarkAsUnseen(context.TODO(), "1jNaXzB2RZX3LY8wVQnfCKyPnv7")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", message.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.MessageMarkAsUnseenParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageMarkAsUnseenParams params = MessageMarkAsUnseenParams.builder()
                      .messageId("1jNaXzB2RZX3LY8wVQnfCKyPnv7")
                      .build();
                  Message message = client.messages().markAsUnseen(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          message = knock.messages.mark_as_unseen("message_id")

          puts(message)
  /v1/users/{user_id}/guides/messages/{message_id}/seen:
    put:
      callbacks: {}
      description: Records that a guide has been seen by a user, triggering any associated seen events.
      operationId: markUserGuideAsSeen
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The unique identifier for the message.
          in: path
          name: message_id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/GuideActionRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GuideActionResponse'
          description: OK
      summary: Mark guide as seen
      tags:
        - Guides
        - Users
  /v1/objects/{collection}/bulk/delete:
    post:
      callbacks: {}
      description: Bulk deletes objects from the specified collection.
      operationId: bulkDeleteObjects
      parameters:
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: A list of object IDs.
          in: query
          name: object_ids[]
          required: true
          schema:
            items:
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Bulk delete objects
      tags:
        - Objects
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.objects.bulk.delete('collection', { object_ids: ['string'] });

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.objects.bulk.delete(
              collection="collection",
              object_ids=["string"],
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.Objects.Bulk.Delete(
              context.TODO(),
              "collection",
              knock.ObjectBulkDeleteParams{
                ObjectIDs: knock.F([]string{"string"}),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.objects.bulk.BulkDeleteParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkDeleteParams params = BulkDeleteParams.builder()
                      .collection("collection")
                      .addObjectId("string")
                      .build();
                  BulkOperation bulkOperation = client.objects().bulk().delete(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          bulk_operation = knock.objects.bulk.delete("collection", object_ids: ["string"])

          puts(bulk_operation)
  /v1/providers/slack/{channel_id}/channels:
    get:
      callbacks: {}
      description: List Slack channels for a Slack workspace.
      operationId: listChannelsForSlackProvider
      parameters:
        - description: The ID of the Knock Slack channel to get channels for.
          in: path
          name: channel_id
          required: true
          schema:
            type: string
        - description: A JSON encoded string containing the access token object reference.
          example: '{"collection":"projects","object_id":"project_123"}'
          in: query
          name: access_token_object
          required: true
          schema:
            type: string
        - description: >-
            Paginate through collections of data by setting the cursor parameter to a next_cursor attribute
            returned by a previous request's response_metadata. Default value fetches the first "page" of the
            collection.
          in: query
          name: query_options.cursor
          required: false
          schema:
            type: string
        - description: The maximum number of channels to return.
          in: query
          name: query_options.limit
          required: false
          schema:
            type: integer
        - description: Set to true to exclude archived channels from the list.
          in: query
          name: query_options.exclude_archived
          required: false
          schema:
            type: boolean
        - description: >-
            Mix and match channel types by providing a comma-separated list of any combination of
            public_channel, private_channel, mpim, im.
          in: query
          name: query_options.types
          required: false
          schema:
            type: string
        - description: Encoded team ID (T1234) to list channels in, required if org token is used.
          in: query
          name: query_options.team_id
          required: false
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChannelsForSlackProviderResponse'
          description: OK
      summary: List channels
      tags:
        - Providers
        - Slack
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const slackListChannelsResponse of client.providers.slack.listChannels('channel_id', {
              access_token_object: 'access_token_object',
            })) {
              console.log(slackListChannelsResponse.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.providers.slack.list_channels(
              channel_id="channel_id",
              access_token_object="access_token_object",
          )
          page = page.slack_channels[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Providers.Slack.ListChannels(
              context.TODO(),
              "channel_id",
              knock.ProviderSlackListChannelsParams{
                AccessTokenObject: knock.F("access_token_object"),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.providers.slack.SlackListChannelsPage;
          import app.knock.api.models.providers.slack.SlackListChannelsParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  SlackListChannelsParams params = SlackListChannelsParams.builder()
                      .channelId("channel_id")
                      .accessTokenObject("access_token_object")
                      .build();
                  SlackListChannelsPage page = client.providers().slack().listChannels(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.providers.slack.list_channels("channel_id", access_token_object: "access_token_object")

          puts(page)
  /v1/workflows/{key}/trigger:
    post:
      callbacks: {}
      description: >-
        Trigger a workflow specified by the key to run for the given recipients, using the parameters
        provided. Returns an identifier for the workflow run request. All workflow runs are executed
        asynchronously.
      operationId: triggerWorkflow (2)
      parameters:
        - description: Key of the workflow to trigger.
          in: path
          name: key
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TriggerWorkflowRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TriggerWorkflowResponse'
          description: OK
      summary: Trigger workflow
      tags:
        - Workflows
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.workflows.trigger('key', { recipients: ['jhammond'] });

            console.log(response.workflow_run_id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.workflows.trigger(
              key="key",
              recipients=["jhammond"],
          )
          print(response.workflow_run_id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
            "github.com/stainless-sdks/knock-go/shared"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Workflows.Trigger(
              context.TODO(),
              "key",
              knock.WorkflowTriggerParams{
                Recipients: knock.F([]knock.RecipientRequestUnionParam{shared.UnionString("jhammond")}),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response.WorkflowRunID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.workflows.WorkflowTriggerParams;
          import app.knock.api.models.workflows.WorkflowTriggerResponse;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  WorkflowTriggerParams params = WorkflowTriggerParams.builder()
                      .key("key")
                      .addRecipient("jhammond")
                      .build();
                  WorkflowTriggerResponse response = client.workflows().trigger(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.workflows.trigger("key", recipients: ["jhammond"])

          puts(response)
  /v1/messages/batch/unarchived:
    post:
      callbacks: {}
      description: Marks the given messages as unarchived.
      operationId: batchMarkMessagesAsUnarchived
      parameters:
        - description: The message IDs to update the status of.
          in: body
          name: message_ids
          required: true
          schema:
            items:
              format: uuid
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                description: The list of messages that were updated
                example:
                  - actors:
                      - user_123
                    archived_at: null
                    channel_id: 123e4567-e89b-12d3-a456-426614174000
                    clicked_at: null
                    data:
                      foo: bar
                    engagement_statuses:
                      - read
                      - seen
                    id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
                    inserted_at: '2021-01-01T00:00:00Z'
                    interacted_at: null
                    link_clicked_at: null
                    metadata:
                      external_id: 123e4567-e89b-12d3-a456-426614174000
                    read_at: null
                    recipient: user_123
                    scheduled_at: null
                    seen_at: null
                    source:
                      __typename: NotificationSource
                      categories:
                        - collaboration
                      key: comment-created
                      version_id: 123e4567-e89b-12d3-a456-426614174000
                    status: sent
                    tenant: tenant_123
                    updated_at: '2021-01-01T00:00:00Z'
                    workflow: comment-created
                items:
                  $ref: '#/components/schemas/Message'
                title: BatchListMessagesResponse
                type: array
          description: OK
      summary: Mark messages as unarchived
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const messages = await client.messages.batch.unarchive({
              message_ids: ['182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e'],
            });

            console.log(messages);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          messages = client.messages.batch.unarchive(
              message_ids=["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"],
          )
          print(messages)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            messages, err := client.Messages.Batch.Unarchive(context.TODO(), knock.MessageBatchUnarchiveParams{
              MessageIDs: knock.F([]string{"182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", messages)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.batch.BatchUnarchiveParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  List<Message> messages = client.messages().batch().unarchive();
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          messages = knock.messages.batch.unarchive(message_ids: ["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"])

          puts(messages)
  /v1/objects/{collection}/{object_id}:
    delete:
      callbacks: {}
      description: Permanently removes an object from the specified collection. This operation cannot be undone.
      operationId: deleteObject
      parameters:
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
      responses:
        '204':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EmptyContentResponse'
          description: No Content
      summary: Delete an object
      tags:
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const object = await client.objects.delete('collection', 'object_id');

            console.log(object);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          object = client.objects.delete(
              collection="collection",
              object_id="object_id",
          )
          print(object)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            object, err := client.Objects.Delete(
              context.TODO(),
              "collection",
              "object_id",
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", object)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectDeleteParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectDeleteParams params = ObjectDeleteParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .build();
                  String object_ = client.objects().delete(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          object = knock.objects.delete("collection", "object_id")

          puts(object)
    get:
      callbacks: {}
      description: >-
        Retrieves a specific object by its ID from the specified collection. Returns the object with all its
        properties.
      operationId: getObject
      parameters:
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Object'
          description: OK
      summary: Get an object
      tags:
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const object = await client.objects.get('collection', 'object_id');

            console.log(object.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          object = client.objects.get(
              collection="collection",
              object_id="object_id",
          )
          print(object.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            object, err := client.Objects.Get(
              context.TODO(),
              "collection",
              "object_id",
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", object.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.Object;
          import app.knock.api.models.objects.ObjectGetParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectGetParams params = ObjectGetParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .build();
                  Object object_ = client.objects().get(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          object = knock.objects.get("collection", "object_id")

          puts(object)
    put:
      callbacks: {}
      description: >-
        Creates a new object or updates an existing one in the specified collection. This operation is used to
        identify objects with their properties and channel data.
      operationId: setObject
      parameters:
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/SetObjectRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Object'
          description: OK
      summary: Set (identify) an object
      tags:
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const object = await client.objects.set('collection', 'object_id');

            console.log(object.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          object = client.objects.set(
              collection="collection",
              object_id="object_id",
          )
          print(object.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            object, err := client.Objects.Set(
              context.TODO(),
              "collection",
              "object_id",
              knock.ObjectSetParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", object.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.Object;
          import app.knock.api.models.objects.ObjectSetParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectSetParams params = ObjectSetParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .build();
                  Object object_ = client.objects().set(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          object = knock.objects.set("collection", "object_id")

          puts(object)
  /v1/messages/{message_id}/unread:
    delete:
      callbacks: {}
      description: Marks a message as unread for the current user, reversing the read state.
      operationId: markMessageUnread (2)
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Mark message as unread
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const message = await client.messages.markAsUnread('1jNaXzB2RZX3LY8wVQnfCKyPnv7');

            console.log(message.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          message = client.messages.mark_as_unread(
              "message_id",
          )
          print(message.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            message, err := client.Messages.MarkAsUnread(context.TODO(), "1jNaXzB2RZX3LY8wVQnfCKyPnv7")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", message.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.MessageMarkAsUnreadParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageMarkAsUnreadParams params = MessageMarkAsUnreadParams.builder()
                      .messageId("1jNaXzB2RZX3LY8wVQnfCKyPnv7")
                      .build();
                  Message message = client.messages().markAsUnread(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          message = knock.messages.mark_as_unread("message_id")

          puts(message)
  /v1/providers/ms-teams/{channel_id}/auth_check:
    get:
      callbacks: {}
      description: >-
        Check if a connection to Microsoft Teams has been authorized for a given Microsoft Teams tenant
        object.
      operationId: msTeamsProviderAuthCheck
      parameters:
        - description: The ID of the Knock Microsoft Teams channel to check.
          in: path
          name: channel_id
          required: true
          schema:
            type: string
        - description: A JSON encoded string containing the Microsoft Teams tenant object reference.
          example: '{"collection":"projects","object_id":"project_123"}'
          in: query
          name: ms_teams_tenant_object
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MsTeamsAuthCheckResponse'
          description: OK
      summary: Check auth
      tags:
        - Providers
        - Microsoft Teams
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.providers.msTeams.checkAuth('channel_id', {
              ms_teams_tenant_object: 'ms_teams_tenant_object',
            });

            console.log(response.connection);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.providers.ms_teams.check_auth(
              channel_id="channel_id",
              ms_teams_tenant_object="ms_teams_tenant_object",
          )
          print(response.connection)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Providers.MsTeams.CheckAuth(
              context.TODO(),
              "channel_id",
              knock.ProviderMsTeamCheckAuthParams{
                MsTeamsTenantObject: knock.F("ms_teams_tenant_object"),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response.Connection)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.providers.msteams.MsTeamCheckAuthParams;
          import app.knock.api.models.providers.msteams.MsTeamCheckAuthResponse;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MsTeamCheckAuthParams params = MsTeamCheckAuthParams.builder()
                      .channelId("channel_id")
                      .msTeamsTenantObject("ms_teams_tenant_object")
                      .build();
                  MsTeamCheckAuthResponse response = client.providers().msTeams().checkAuth(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          response = knock.providers.ms_teams.check_auth("channel_id", ms_teams_tenant_object:
          "ms_teams_tenant_object")


          puts(response)
  /v1/messages/{message_id}/seen:
    delete:
      callbacks: {}
      description: Marks a message as unseen for the current user, reversing the seen state.
      operationId: markMessageUnseen
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Mark message as unseen
      tags:
        - Messages
    put:
      callbacks: {}
      description: >-
        Marks a message as seen for the current user. This indicates that the user has viewed the message in
        their feed or inbox.
      operationId: markMessageSeen
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Mark message as seen
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const message = await client.messages.markAsSeen('1jNaXzB2RZX3LY8wVQnfCKyPnv7');

            console.log(message.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          message = client.messages.mark_as_seen(
              "message_id",
          )
          print(message.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            message, err := client.Messages.MarkAsSeen(context.TODO(), "1jNaXzB2RZX3LY8wVQnfCKyPnv7")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", message.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.MessageMarkAsSeenParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageMarkAsSeenParams params = MessageMarkAsSeenParams.builder()
                      .messageId("1jNaXzB2RZX3LY8wVQnfCKyPnv7")
                      .build();
                  Message message = client.messages().markAsSeen(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          message = knock.messages.mark_as_seen("message_id")

          puts(message)
  /v1/users/{user_id}/channel_data/{channel_id}:
    delete:
      callbacks: {}
      description: Deletes channel data for a specific user and channel ID.
      operationId: unsetUserChannelData
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The unique identifier for the channel.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
      responses:
        '204':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EmptyContentResponse'
          description: No Content
      summary: Unset channel data
      tags:
        - Channel data
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.users.unsetChannelData('user_id', '182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e');

            console.log(response);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.users.unset_channel_data(
              user_id="user_id",
              channel_id="182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
          )
          print(response)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Users.UnsetChannelData(
              context.TODO(),
              "user_id",
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.UserUnsetChannelDataParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserUnsetChannelDataParams params = UserUnsetChannelDataParams.builder()
                      .userId("user_id")
                      .channelId("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .build();
                  String response = client.users().unsetChannelData(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.users.unset_channel_data("user_id", "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")

          puts(response)
    get:
      callbacks: {}
      description: Retrieves the channel data for a specific user and channel ID.
      operationId: getUserChannelData
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The unique identifier for the channel.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChannelData'
          description: OK
      summary: Get channel data
      tags:
        - Channel data
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const channelData = await client.users.getChannelData('user_id', '182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e');

            console.log(channelData.channel_id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          channel_data = client.users.get_channel_data(
              user_id="user_id",
              channel_id="182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
          )
          print(channel_data.channel_id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            channelData, err := client.Users.GetChannelData(
              context.TODO(),
              "user_id",
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", channelData.ChannelID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.recipients.channeldata.ChannelData;
          import app.knock.api.models.users.UserGetChannelDataParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserGetChannelDataParams params = UserGetChannelDataParams.builder()
                      .userId("user_id")
                      .channelId("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .build();
                  ChannelData channelData = client.users().getChannelData(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          channel_data = knock.users.get_channel_data("user_id", "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")

          puts(channel_data)
    put:
      callbacks: {}
      description: Updates or creates channel data for a specific user and channel ID.
      operationId: setUserChannelData
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The unique identifier for the channel.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ChannelDataRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChannelData'
          description: OK
      summary: Set channel data
      tags:
        - Channel data
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const channelData = await client.users.setChannelData('user_id', '182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e', {
              data: { __typename: 'PushChannelData', tokens: ['push_token_1'] },
            });

            console.log(channelData.channel_id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          channel_data = client.users.set_channel_data(
              user_id="user_id",
              channel_id="182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
              data={
                  "_typename": "PushChannelData",
                  "tokens": ["push_token_1"],
              },
          )
          print(channel_data.channel_id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            channelData, err := client.Users.SetChannelData(
              context.TODO(),
              "user_id",
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
              knock.UserSetChannelDataParams{
                ChannelDataRequest: knock.ChannelDataRequestParam{
                  Data: knock.F[knock.ChannelDataRequestDataUnionParam](knock.PushChannelDataParam{
                    Typename: knock.F(knock.PushChannelData_TypenamePushChannelData),
                    Tokens: knock.F([]string{"push_token_1"}),
                  }),
                },
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", channelData.ChannelID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.recipients.channeldata.ChannelData;
          import app.knock.api.models.recipients.channeldata.ChannelDataRequest;
          import app.knock.api.models.recipients.channeldata.PushChannelData;
          import app.knock.api.models.users.UserSetChannelDataParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserSetChannelDataParams params = UserSetChannelDataParams.builder()
                      .userId("user_id")
                      .channelId("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .channelDataRequest(ChannelDataRequest.builder()
                          .data(PushChannelData.builder()
                              ._typename(PushChannelData._Typename.PUSH_CHANNEL_DATA)
                              .addToken("push_token_1")
                              .build())
                          .build())
                      .build();
                  ChannelData channelData = client.users().setChannelData(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          channel_data = knock.users.set_channel_data(
            "user_id",
            "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
            data: {__typename: :PushChannelData, tokens: ["push_token_1"]}
          )

          puts(channel_data)
  /v1/messages/{message_id}/events:
    get:
      callbacks: {}
      description: Returns a paginated list of events for the specified message.
      operationId: listMessageEvents
      parameters:
        - description: The ID of the message to fetch events for.
          in: path
          name: message_id
          required: true
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListMessageEventsResponse'
          description: OK
      summary: List events
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const messageEvent of client.messages.listEvents('message_id')) {
              console.log(messageEvent.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.messages.list_events(
              message_id="message_id",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Messages.ListEvents(
              context.TODO(),
              "message_id",
              knock.MessageListEventsParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.MessageListEventsPage;
          import app.knock.api.models.messages.MessageListEventsParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageListEventsParams params = MessageListEventsParams.builder()
                      .messageId("message_id")
                      .build();
                  MessageListEventsPage page = client.messages().listEvents(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.messages.list_events("message_id")

          puts(page)
  /v1/providers/slack/{channel_id}/auth_check:
    get:
      callbacks: {}
      description: Check if a Slack channel is authenticated.
      operationId: slackProviderAuthCheck
      parameters:
        - description: The ID of the Knock Slack channel to check.
          in: path
          name: channel_id
          required: true
          schema:
            type: string
        - description: A JSON encoded string containing the access token object reference.
          example: '{"collection":"projects","object_id":"project_123"}'
          in: query
          name: access_token_object
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SlackAuthCheckResponse'
          description: OK
      summary: Check auth
      tags:
        - Providers
        - Slack
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.providers.slack.checkAuth('channel_id', {
              access_token_object: 'access_token_object',
            });

            console.log(response.connection);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.providers.slack.check_auth(
              channel_id="channel_id",
              access_token_object="access_token_object",
          )
          print(response.connection)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Providers.Slack.CheckAuth(
              context.TODO(),
              "channel_id",
              knock.ProviderSlackCheckAuthParams{
                AccessTokenObject: knock.F("access_token_object"),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response.Connection)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.providers.slack.SlackCheckAuthParams;
          import app.knock.api.models.providers.slack.SlackCheckAuthResponse;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  SlackCheckAuthParams params = SlackCheckAuthParams.builder()
                      .channelId("channel_id")
                      .accessTokenObject("access_token_object")
                      .build();
                  SlackCheckAuthResponse response = client.providers().slack().checkAuth(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          response = knock.providers.slack.check_auth("channel_id", access_token_object:
          "access_token_object")


          puts(response)
  /v1/tenants:
    get:
      callbacks: {}
      description: List tenants for the current environment.
      operationId: listTenants
      parameters:
        - description: Filter tenants by ID.
          in: query
          name: tenant_id
          required: false
          schema:
            type: string
        - description: Filter tenants by name.
          in: query
          name: name
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListTenantsResponse'
          description: OK
      summary: List tenants
      tags:
        - Tenants
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const tenant of client.tenants.list()) {
              console.log(tenant.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.tenants.list()
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Tenants.List(context.TODO(), knock.TenantListParams{

            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.tenants.TenantListPage;
          import app.knock.api.models.tenants.TenantListParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  TenantListPage page = client.tenants().list();
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.tenants.list

          puts(page)
  /v1/messages/batch/seen:
    post:
      callbacks: {}
      description: Marks the given messages as seen.
      operationId: batchMarkMessagesAsSeen
      parameters:
        - description: The message IDs to update the status of.
          in: body
          name: message_ids
          required: true
          schema:
            items:
              format: uuid
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                description: The list of messages that were updated
                example:
                  - actors:
                      - user_123
                    archived_at: null
                    channel_id: 123e4567-e89b-12d3-a456-426614174000
                    clicked_at: null
                    data:
                      foo: bar
                    engagement_statuses:
                      - read
                      - seen
                    id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
                    inserted_at: '2021-01-01T00:00:00Z'
                    interacted_at: null
                    link_clicked_at: null
                    metadata:
                      external_id: 123e4567-e89b-12d3-a456-426614174000
                    read_at: null
                    recipient: user_123
                    scheduled_at: null
                    seen_at: null
                    source:
                      __typename: NotificationSource
                      categories:
                        - collaboration
                      key: comment-created
                      version_id: 123e4567-e89b-12d3-a456-426614174000
                    status: sent
                    tenant: tenant_123
                    updated_at: '2021-01-01T00:00:00Z'
                    workflow: comment-created
                items:
                  $ref: '#/components/schemas/Message'
                title: BatchListMessagesResponse
                type: array
          description: OK
      summary: Mark messages as seen
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const messages = await client.messages.batch.markAsSeen({
              message_ids: ['182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e'],
            });

            console.log(messages);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          messages = client.messages.batch.mark_as_seen(
              message_ids=["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"],
          )
          print(messages)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            messages, err := client.Messages.Batch.MarkAsSeen(context.TODO(), knock.MessageBatchMarkAsSeenParams{
              MessageIDs: knock.F([]string{"182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", messages)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.batch.BatchMarkAsSeenParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  List<Message> messages = client.messages().batch().markAsSeen();
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          messages = knock.messages.batch.mark_as_seen(message_ids: ["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"])

          puts(messages)
  /v1/objects/{collection}/{object_id}/preferences/{preference_set_id}/channel_types/{type}:
    put:
      callbacks: {}
      deprecated: true
      description: Updates a specific channel type preference for an object's preference set.
      operationId: updateObjectPreferenceChannelType
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update a channel type preference
      tags:
        - Objects
        - Preferences
  /v1/messages/batch/unseen:
    post:
      callbacks: {}
      description: Marks the given messages as unseen.
      operationId: batchMarkMessagesAsUnseen
      parameters:
        - description: The message IDs to update the status of.
          in: body
          name: message_ids
          required: true
          schema:
            items:
              format: uuid
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                description: The list of messages that were updated
                example:
                  - actors:
                      - user_123
                    archived_at: null
                    channel_id: 123e4567-e89b-12d3-a456-426614174000
                    clicked_at: null
                    data:
                      foo: bar
                    engagement_statuses:
                      - read
                      - seen
                    id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
                    inserted_at: '2021-01-01T00:00:00Z'
                    interacted_at: null
                    link_clicked_at: null
                    metadata:
                      external_id: 123e4567-e89b-12d3-a456-426614174000
                    read_at: null
                    recipient: user_123
                    scheduled_at: null
                    seen_at: null
                    source:
                      __typename: NotificationSource
                      categories:
                        - collaboration
                      key: comment-created
                      version_id: 123e4567-e89b-12d3-a456-426614174000
                    status: sent
                    tenant: tenant_123
                    updated_at: '2021-01-01T00:00:00Z'
                    workflow: comment-created
                items:
                  $ref: '#/components/schemas/Message'
                title: BatchListMessagesResponse
                type: array
          description: OK
      summary: Mark messages as unseen
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const messages = await client.messages.batch.markAsUnseen({
              message_ids: ['182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e'],
            });

            console.log(messages);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          messages = client.messages.batch.mark_as_unseen(
              message_ids=["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"],
          )
          print(messages)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            messages, err := client.Messages.Batch.MarkAsUnseen(context.TODO(), knock.MessageBatchMarkAsUnseenParams{
              MessageIDs: knock.F([]string{"182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", messages)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.batch.BatchMarkAsUnseenParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  List<Message> messages = client.messages().batch().markAsUnseen();
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          messages = knock.messages.batch.mark_as_unseen(message_ids:
          ["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"])


          puts(messages)
  /v1/users/{user_id}/merge:
    post:
      callbacks: {}
      description: >-
        Merge two users together, where the user specified with the `from_user_id` param will be merged into
        the user specified by `user_id`.
      operationId: mergeUser
      parameters:
        - description: The id of the user to merge into.
          in: path
          name: user_id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MergeUserRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
          description: OK
      summary: Merge users
      tags:
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const user = await client.users.merge('user_id', { from_user_id: 'user_1' });

            console.log(user.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          user = client.users.merge(
              user_id="user_id",
              from_user_id="user_1",
          )
          print(user.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            user, err := client.Users.Merge(
              context.TODO(),
              "user_id",
              knock.UserMergeParams{
                FromUserID: knock.F("user_1"),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", user.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.User;
          import app.knock.api.models.users.UserMergeParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserMergeParams params = UserMergeParams.builder()
                      .userId("user_id")
                      .fromUserId("user_1")
                      .build();
                  User user = client.users().merge(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          user = knock.users.merge("user_id", from_user_id: "user_1")

          puts(user)
  /v1/objects/{collection}/{object_id}/preferences:
    get:
      callbacks: {}
      description: Returns a paginated list of preference sets for the specified object.
      operationId: listObjectPreferenceSets
      parameters:
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                description: A list of preference sets for the object
                example:
                  - __typename: PreferenceSet
                    categories:
                      marketing: false
                      transactional:
                        channel_types:
                          email: false
                    channel_types:
                      email: true
                      push: false
                      sms:
                        conditions:
                          - argument: US
                            operator: equal_to
                            variable: recipient.country_code
                    id: default
                    workflows: null
                items:
                  $ref: '#/components/schemas/PreferenceSet'
                title: ListObjectPreferenceSetsResponse
                type: array
          description: OK
      summary: List preference sets
      tags:
        - Objects
        - Preferences
  /v1/messages/{message_id}/read:
    delete:
      callbacks: {}
      description: Marks a message as unread for the current user, reversing the read state.
      operationId: markMessageUnread
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Mark message as unread
      tags:
        - Messages
    put:
      callbacks: {}
      description: >-
        Marks a message as read for the current user. This indicates that the user has read the message
        content.
      operationId: markMessageRead
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Mark message as read
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const message = await client.messages.markAsRead('1jNaXzB2RZX3LY8wVQnfCKyPnv7');

            console.log(message.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          message = client.messages.mark_as_read(
              "message_id",
          )
          print(message.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            message, err := client.Messages.MarkAsRead(context.TODO(), "1jNaXzB2RZX3LY8wVQnfCKyPnv7")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", message.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.MessageMarkAsReadParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageMarkAsReadParams params = MessageMarkAsReadParams.builder()
                      .messageId("1jNaXzB2RZX3LY8wVQnfCKyPnv7")
                      .build();
                  Message message = client.messages().markAsRead(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          message = knock.messages.mark_as_read("message_id")

          puts(message)
  /v1/users/bulk/preferences:
    post:
      callbacks: {}
      description: >-
        Sets preferences for multiple users in a single operation. Supports either setting the same
        preferences for multiple users or specific preferences for each user.
      operationId: bulkSetUserPreferences
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BulkSetUserPreferencesRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Bulk set preferences
      tags:
        - Users
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.users.bulk.setPreferences({
              preferences: {},
              user_ids: ['user_1', 'user_2'],
            });

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.users.bulk.set_preferences(
              preferences={},
              user_ids=["user_1", "user_2"],
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.Users.Bulk.SetPreferences(context.TODO(), knock.UserBulkSetPreferencesParams{
              Preferences: knock.F(knock.PreferenceSetRequestParam{

              }),
              UserIDs: knock.F([]string{"user_1", "user_2"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.recipients.preferences.PreferenceSetRequest;
          import app.knock.api.models.users.bulk.BulkSetPreferencesParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkSetPreferencesParams params = BulkSetPreferencesParams.builder()
                      .preferences(PreferenceSetRequest.builder().build())
                      .addUserId("user_1")
                      .addUserId("user_2")
                      .build();
                  BulkOperation bulkOperation = client.users().bulk().setPreferences(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          bulk_operation = knock.users.bulk.set_preferences(preferences: {}, user_ids: ["user_1", "user_2"])

          puts(bulk_operation)
  /v1/users/{user_id}/guides/{channel_id}:
    get:
      callbacks: {}
      description: Returns a list of eligible in-app guides for a specific user and channel.
      operationId: listUserGuides
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The unique identifier for the channel.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
        - description: The tenant ID to filter guides by.
          in: query
          name: tenant
          required: false
          schema:
            type: string
        - description: The data to filter guides by.
          in: query
          name: data
          required: false
          schema:
            type: string
        - description: The type of guides to filter by.
          in: query
          name: type
          required: false
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GuidesResponse'
          description: OK
      summary: List guides
      tags:
        - Guides
        - Users
  /v1/schedules:
    delete:
      callbacks: {}
      description: >-
        Permanently deletes one or more schedules identified by the provided schedule IDs. This operation
        cannot be undone.
      operationId: deleteSchedules
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DeleteSchedulesRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SchedulesResponse'
          description: OK
      summary: Delete schedules
      tags:
        - Schedules
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const schedules = await client.schedules.delete({ schedule_ids: ['123e4567-e89b-12d3-a456-426614174000'] });

            console.log(schedules);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          schedules = client.schedules.delete(
              schedule_ids=["123e4567-e89b-12d3-a456-426614174000"],
          )
          print(schedules)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            schedules, err := client.Schedules.Delete(context.TODO(), knock.ScheduleDeleteParams{
              ScheduleIDs: knock.F([]string{"123e4567-e89b-12d3-a456-426614174000"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", schedules)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.schedules.Schedule;
          import app.knock.api.models.schedules.ScheduleDeleteParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ScheduleDeleteParams params = ScheduleDeleteParams.builder()
                      .addScheduleId("123e4567-e89b-12d3-a456-426614174000")
                      .build();
                  List<Schedule> schedules = client.schedules().delete(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          schedules = knock.schedules.delete(schedule_ids: ["123e4567-e89b-12d3-a456-426614174000"])

          puts(schedules)
    get:
      callbacks: {}
      description: >-
        Returns a paginated list of schedules for the current environment, filtered by workflow and optionally
        by recipients and tenant.
      operationId: listSchedules
      parameters:
        - description: Filter by workflow key.
          in: query
          name: workflow
          required: true
          schema:
            type: string
        - description: Filter by recipient IDs.
          in: query
          name: recipients[]
          required: false
          schema:
            description: A list of recipient IDs to filter by.
            items:
              type: string
            type: array
        - description: Filter by tenant ID.
          in: query
          name: tenant
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListSchedulesResponse'
          description: OK
      summary: List schedules
      tags:
        - Schedules
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const schedule of client.schedules.list({ workflow: 'workflow' })) {
              console.log(schedule.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.schedules.list(
              workflow="workflow",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Schedules.List(context.TODO(), knock.ScheduleListParams{
              Workflow: knock.F("workflow"),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.schedules.ScheduleListPage;
          import app.knock.api.models.schedules.ScheduleListParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ScheduleListParams params = ScheduleListParams.builder()
                      .workflow("workflow")
                      .build();
                  ScheduleListPage page = client.schedules().list(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.schedules.list(workflow: "workflow")

          puts(page)
    post:
      callbacks: {}
      description: >-
        Creates one or more schedules for a workflow with the specified recipients, timing, and data.
        Schedules can be one-time or recurring.
      operationId: createSchedules
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateSchedulesRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SchedulesResponse'
          description: OK
      summary: Create schedules
      tags:
        - Schedules
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const schedules = await client.schedules.create({
              recipients: ['user_123'],
              repeats: [{ __typename: 'ScheduleRepeat', frequency: 'daily' }],
              workflow: 'comment-created',
            });

            console.log(schedules);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          schedules = client.schedules.create(
              recipients=["user_123"],
              repeats=[{
                  "_typename": "ScheduleRepeat",
                  "frequency": "daily",
              }],
              workflow="comment-created",
          )
          print(schedules)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
            "github.com/stainless-sdks/knock-go/shared"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            schedules, err := client.Schedules.New(context.TODO(), knock.ScheduleNewParams{
              Recipients: knock.F([]knock.ScheduleNewParamsRecipientUnion{shared.UnionString("user_123")}),
              Repeats: knock.F([]knock.ScheduleRepeatRuleParam{knock.ScheduleRepeatRuleParam{
                Typename: knock.F("ScheduleRepeat"),
                Frequency: knock.F(knock.ScheduleRepeatRuleFrequencyDaily),
              }}),
              Workflow: knock.F("comment-created"),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", schedules)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.schedules.Schedule;
          import app.knock.api.models.schedules.ScheduleCreateParams;
          import app.knock.api.models.schedules.ScheduleRepeatRule;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ScheduleCreateParams params = ScheduleCreateParams.builder()
                      .addRecipient("user_123")
                      .addRepeat(ScheduleRepeatRule.builder()
                          ._typename("ScheduleRepeat")
                          .frequency(ScheduleRepeatRule.Frequency.DAILY)
                          .build())
                      .workflow("comment-created")
                      .build();
                  List<Schedule> schedules = client.schedules().create(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          schedules = knock.schedules.create(
            recipients: ["user_123"],
            repeats: [{__typename: "ScheduleRepeat", frequency: :daily}],
            workflow: "comment-created"
          )

          puts(schedules)
    put:
      callbacks: {}
      description: >-
        Updates one or more existing schedules with new timing, data, or other properties. All specified
        schedule IDs will be updated with the same values.
      operationId: updateSchedules
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateSchedulesRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SchedulesResponse'
          description: OK
      summary: Update schedules
      tags:
        - Schedules
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const schedules = await client.schedules.update({ schedule_ids: ['123e4567-e89b-12d3-a456-426614174000'] });

            console.log(schedules);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          schedules = client.schedules.update(
              schedule_ids=["123e4567-e89b-12d3-a456-426614174000"],
          )
          print(schedules)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            schedules, err := client.Schedules.Update(context.TODO(), knock.ScheduleUpdateParams{
              ScheduleIDs: knock.F([]string{"123e4567-e89b-12d3-a456-426614174000"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", schedules)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.schedules.Schedule;
          import app.knock.api.models.schedules.ScheduleUpdateParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ScheduleUpdateParams params = ScheduleUpdateParams.builder()
                      .addScheduleId("123e4567-e89b-12d3-a456-426614174000")
                      .build();
                  List<Schedule> schedules = client.schedules().update(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          schedules = knock.schedules.update(schedule_ids: ["123e4567-e89b-12d3-a456-426614174000"])

          puts(schedules)
  /v1/objects/{collection}/bulk/subscriptions/add:
    post:
      callbacks: {}
      description: >-
        Add subscriptions for all objects in a single collection. If a subscription for an object in the
        collection already exists, it will be updated.
      operationId: bulkAddSubscriptions
      parameters:
        - description: The collection this object belongs to.
          example: projects
          in: path
          name: collection
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BulkUpsertSubscriptionsRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Bulk add subscriptions
      tags:
        - Objects
        - Subscriptions
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.objects.bulk.addSubscriptions('projects', {
              subscriptions: [{ id: 'project-1', recipients: [{ id: 'user_1' }] }],
            });

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.objects.bulk.add_subscriptions(
              collection="projects",
              subscriptions=[{
                  "id": "project-1",
                  "recipients": [{
                      "id": "user_1"
                  }],
              }],
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.Objects.Bulk.AddSubscriptions(
              context.TODO(),
              "projects",
              knock.ObjectBulkAddSubscriptionsParams{
                Subscriptions: knock.F([]knock.ObjectBulkAddSubscriptionsParamsSubscription{knock.ObjectBulkAddSubscriptionsParamsSubscription{
                  ID: knock.F("project-1"),
                  Recipients: knock.F([]knock.RecipientRequestUnionParam{knock.InlineIdentifyUserRequestParam{
                    ID: knock.F("user_1"),
                  }}),
                }}),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.objects.bulk.BulkAddSubscriptionsParams;
          import app.knock.api.models.users.InlineIdentifyUserRequest;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkAddSubscriptionsParams params = BulkAddSubscriptionsParams.builder()
                      .collection("projects")
                      .addSubscription(BulkAddSubscriptionsParams.Subscription.builder()
                          .id("project-1")
                          .addRecipient(InlineIdentifyUserRequest.builder()
                              .id("user_1")
                              .build())
                          .build())
                      .build();
                  BulkOperation bulkOperation = client.objects().bulk().addSubscriptions(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          bulk_operation = knock.objects.bulk.add_subscriptions(
            "collection",
            subscriptions: [{id: "project-1", recipients: [{id: "user_1"}]}]
          )

          puts(bulk_operation)
  /v1/messages/batch/content:
    get:
      callbacks: {}
      description: Get the contents of multiple messages in a single request.
      operationId: batchGetMessageContents
      parameters:
        - description: The IDs of the messages to fetch contents of.
          in: query
          name: message_ids[]
          required: true
          schema:
            items:
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                description: A list of message contents
                example:
                  - __typename: MessageContent
                    data:
                      __typename: MessageSmsContent
                      body: Hello, world!
                      to: user_123
                    inserted_at: '2021-01-01T00:00:00Z'
                    message_id: 2FVHPWxRqNuXQ9krvNP5A6Z4qXe
                items:
                  $ref: '#/components/schemas/MessageContents'
                title: BatchGetMessageContentsResponse
                type: array
          description: OK
      summary: Batch get message contents
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.messages.batch.getContent({ message_ids: ['string'] });

            console.log(response);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.messages.batch.get_content(
              message_ids=["string"],
          )
          print(response)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Messages.Batch.GetContent(context.TODO(), knock.MessageBatchGetContentParams{
              MessageIDs: knock.F([]string{"string"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.batch.BatchGetContentParams;
          import app.knock.api.models.messages.batch.BatchGetContentResponse;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BatchGetContentParams params = BatchGetContentParams.builder()
                      .addMessageId("string")
                      .build();
                  List<BatchGetContentResponse> response = client.messages().batch().getContent(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.messages.batch.get_content(message_ids: ["string"])

          puts(response)
  /v1/users/{user_id}/preferences/{preference_set_id}/workflows/{key}:
    put:
      callbacks: {}
      deprecated: true
      description: Updates a single workflow in a specific user preference set. This operation is deprecated.
      operationId: updateUserPreferenceWorkflow
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update workflow in preference set
      tags:
        - Users
        - Preferences
  /v1/users/bulk/identify:
    post:
      callbacks: {}
      description: >-
        Identifies multiple users in a single operation. Allows creating or updating up to 100 users in a
        single batch with various properties, preferences, and channel data.
      operationId: bulkIdentifyUsers
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BulkIdentifyUsersRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Bulk identify users
      tags:
        - Users
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.users.bulk.identify({ users: [{ id: 'user_1' }] });

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.users.bulk.identify(
              users=[{
                  "id": "user_1"
              }],
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.Users.Bulk.Identify(context.TODO(), knock.UserBulkIdentifyParams{
              Users: knock.F([]knock.InlineIdentifyUserRequestParam{knock.InlineIdentifyUserRequestParam{
                ID: knock.F("user_1"),
              }}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.users.InlineIdentifyUserRequest;
          import app.knock.api.models.users.bulk.BulkIdentifyParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkIdentifyParams params = BulkIdentifyParams.builder()
                      .addUser(InlineIdentifyUserRequest.builder()
                          .id("user_1")
                          .build())
                      .build();
                  BulkOperation bulkOperation = client.users().bulk().identify(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          bulk_operation = knock.users.bulk.identify(users: [{id: "user_1"}])

          puts(bulk_operation)
  /v1/messages/{message_id}/content:
    get:
      callbacks: {}
      description: >-
        Returns the fully rendered contents of a message, where the response depends on which channel the
        message was sent through.
      operationId: getMessageContents
      parameters:
        - description: The ID of the message to fetch contents of.
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MessageContents'
          description: OK
      summary: Get message content
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.messages.getContent('message_id');

            console.log(response.message_id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.messages.get_content(
              "message_id",
          )
          print(response.message_id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Messages.GetContent(context.TODO(), "message_id")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response.MessageID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.MessageGetContentParams;
          import app.knock.api.models.messages.MessageGetContentResponse;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageGetContentParams params = MessageGetContentParams.builder()
                      .messageId("message_id")
                      .build();
                  MessageGetContentResponse response = client.messages().getContent(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.messages.get_content("message_id")

          puts(response)
  /v1/users/{user_id}/preferences/{preference_set_id}/categories/{key}:
    put:
      callbacks: {}
      deprecated: true
      description: Updates a single category in a specific user preference set. This operation is deprecated.
      operationId: updateUserPreferenceCategory
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update category in preference set
      tags:
        - Users
        - Preferences
  /v1/notify/cancel:
    post:
      callbacks: {}
      description: Cancels a previously triggered workflow using the provided cancellation key.
      operationId: cancelWorkflow (2)
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Cancel Request'
        description: Cancel Payload
        required: true
      responses:
        '204':
          content:
            application/json: {}
          description: No Content
      summary: Cancel workflow
      tags:
        - Workflow Triggers
  /v1/tenants/bulk/delete:
    post:
      callbacks: {}
      description: Delete multiple tenants in a single operation. This operation cannot be undone.
      operationId: bulkDeleteTenants
      parameters:
        - description: The IDs of the tenants to delete.
          in: query
          name: tenant_ids[]
          required: true
          schema:
            items:
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Bulk delete tenants
      tags:
        - Tenants
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.tenants.bulk.delete({ tenant_ids: ['string'] });

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.tenants.bulk.delete(
              tenant_ids=["string"],
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.Tenants.Bulk.Delete(context.TODO(), knock.TenantBulkDeleteParams{
              TenantIDs: knock.F([]string{"string"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.tenants.bulk.BulkDeleteParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkDeleteParams params = BulkDeleteParams.builder()
                      .addTenantId("string")
                      .build();
                  BulkOperation bulkOperation = client.tenants().bulk().delete(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          bulk_operation = knock.tenants.bulk.delete(tenant_ids: ["string"])

          puts(bulk_operation)
  /v1/objects/{collection}/{object_id}/preferences/{preference_set_id}/channel_types:
    put:
      callbacks: {}
      deprecated: true
      description: Updates the channel type preferences for an object's preference set.
      operationId: updateObjectPreferenceChannelTypes
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update channel types in preference set
      tags:
        - Objects
        - Preferences
  /v1/objects/{collection}/{object_id}/preferences/{preference_set_id}:
    get:
      callbacks: {}
      description: Returns the preference set for the specified object.
      operationId: getObjectPreferenceSet
      parameters:
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: Unique identifier for the preference set.
          in: path
          name: preference_set_id
          required: true
          schema:
            default: default
            example: default
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Get a preference set
      tags:
        - Objects
        - Preferences
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const preferenceSet = await client.objects.getPreferences('collection', 'object_id', 'default');

            console.log(preferenceSet.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          preference_set = client.objects.get_preferences(
              collection="collection",
              object_id="object_id",
              preference_set_id="default",
          )
          print(preference_set.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            preferenceSet, err := client.Objects.GetPreferences(
              context.TODO(),
              "collection",
              "object_id",
              "default",
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", preferenceSet.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectGetPreferencesParams;
          import app.knock.api.models.recipients.preferences.PreferenceSet;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectGetPreferencesParams params = ObjectGetPreferencesParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .preferenceSetId("default")
                      .build();
                  PreferenceSet preferenceSet = client.objects().getPreferences(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          preference_set = knock.objects.get_preferences("collection", "object_id", "default")

          puts(preference_set)
    put:
      callbacks: {}
      description: Updates the preference set for the specified object.
      operationId: updateObjectPreferenceSet
      parameters:
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: Unique identifier for the preference set.
          in: path
          name: preference_set_id
          required: true
          schema:
            default: default
            example: default
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PreferenceSetRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update a preference set
      tags:
        - Objects
        - Preferences
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const preferenceSet = await client.objects.setPreferences('collection', 'object_id', 'default');

            console.log(preferenceSet.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          preference_set = client.objects.set_preferences(
              collection="collection",
              object_id="object_id",
              preference_set_id="default",
          )
          print(preference_set.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            preferenceSet, err := client.Objects.SetPreferences(
              context.TODO(),
              "collection",
              "object_id",
              "default",
              knock.ObjectSetPreferencesParams{
                PreferenceSetRequest: knock.PreferenceSetRequestParam{

                },
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", preferenceSet.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectSetPreferencesParams;
          import app.knock.api.models.recipients.preferences.PreferenceSet;
          import app.knock.api.models.recipients.preferences.PreferenceSetRequest;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectSetPreferencesParams params = ObjectSetPreferencesParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .preferenceSetId("default")
                      .preferenceSetRequest(PreferenceSetRequest.builder().build())
                      .build();
                  PreferenceSet preferenceSet = client.objects().setPreferences(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          preference_set = knock.objects.set_preferences("collection", "object_id", "default")

          puts(preference_set)
  /v1/messages/{message_id}/activities:
    get:
      callbacks: {}
      description: Returns a paginated list of activities for the specified message.
      operationId: listMessageActivities
      parameters:
        - description: The ID of the message to fetch activities for.
          in: path
          name: message_id
          required: true
          schema:
            type: string
        - description: The trigger data to filter activities by.
          in: query
          name: trigger_data
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListActivitiesResponse'
          description: OK
      summary: List activities
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const activity of client.messages.listActivities('message_id')) {
              console.log(activity.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.messages.list_activities(
              message_id="message_id",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Messages.ListActivities(
              context.TODO(),
              "message_id",
              knock.MessageListActivitiesParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.MessageListActivitiesPage;
          import app.knock.api.models.messages.MessageListActivitiesParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageListActivitiesParams params = MessageListActivitiesParams.builder()
                      .messageId("message_id")
                      .build();
                  MessageListActivitiesPage page = client.messages().listActivities(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.messages.list_activities("message_id")

          puts(page)
  /v1/channels/{channel_id}/messages/bulk/{action}:
    post:
      callbacks: {}
      description: >-
        Bulk update messages for a specific channel. The channel is specified by the `channel_id` parameter.
        The action to perform is specified by the `action` parameter, where the action is a status change
        action (e.g. `archive`, `unarchive`).
      operationId: bulkUpdateMessagesForChannel
      parameters:
        - description: The ID of the channel to update messages for.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
        - description: The action to perform on the messages.
          in: path
          name: action
          required: true
          schema:
            enum:
              - seen
              - unseen
              - read
              - unread
              - archived
              - unarchived
              - interacted
              - archive
              - unarchive
              - delete
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BulkUpdateMessagesForChannelRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Bulk update messages
      tags:
        - Messages
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.channels.bulk.updateMessageStatus(
              '182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e',
              'seen',
            );

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.channels.bulk.update_message_status(
              channel_id="182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
              action="seen",
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.Channels.Bulk.UpdateMessageStatus(
              context.TODO(),
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
              knock.ChannelBulkUpdateMessageStatusParamsActionSeen,
              knock.ChannelBulkUpdateMessageStatusParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.channels.bulk.BulkUpdateMessageStatusParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkUpdateMessageStatusParams params = BulkUpdateMessageStatusParams.builder()
                      .channelId("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .action(BulkUpdateMessageStatusParams.Action.SEEN)
                      .build();
                  BulkOperation bulkOperation = client.channels().bulk().updateMessageStatus(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          bulk_operation = knock.channels.bulk.update_message_status("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
          :seen)


          puts(bulk_operation)
  /v1/users/{user_id}/feeds/{channel_id}:
    get:
      callbacks: {}
      description: Returns a paginated list of feed items for a user, including metadata about the feed.
      operationId: listUserInAppFeedItems
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The unique identifier for the channel.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
        - description: The status of the feed items.
          example: unread
          in: query
          name: status
          required: false
          schema:
            enum:
              - unread
              - read
              - unseen
              - seen
              - all
            type: string
        - description: The source of the feed items.
          example: my_source
          in: query
          name: source
          required: false
          schema:
            type: string
        - description: The tenant associated with the feed items.
          example: my_tenant
          in: query
          name: tenant
          required: false
          schema:
            type: string
        - description: Whether the feed items have a tenant.
          example: true
          in: query
          name: has_tenant
          required: false
          schema:
            type: boolean
        - description: The workflow categories of the feed items.
          example:
            - my_workflow_category
          in: query
          name: workflow_categories[]
          required: false
          schema:
            items:
              type: string
            type: array
        - description: The archived status of the feed items.
          example: exclude
          in: query
          name: archived
          required: false
          schema:
            enum:
              - exclude
              - include
              - only
            type: string
        - description: The trigger data of the feed items (as a JSON string).
          example: '{ "key": "value" }'
          in: query
          name: trigger_data
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserInAppFeedResponse'
          description: OK
      summary: List feed items
      tags:
        - Feeds
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const feedListItemsResponse of client.users.feeds.listItems(
              'user_id',
              '182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e',
            )) {
              console.log(feedListItemsResponse.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.users.feeds.list_items(
              user_id="user_id",
              channel_id="182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Users.Feeds.ListItems(
              context.TODO(),
              "user_id",
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
              knock.UserFeedListItemsParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.feeds.FeedListItemsPage;
          import app.knock.api.models.users.feeds.FeedListItemsParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  FeedListItemsParams params = FeedListItemsParams.builder()
                      .userId("user_id")
                      .channelId("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .build();
                  FeedListItemsPage page = client.users().feeds().listItems(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.users.feeds.list_items("user_id", "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")

          puts(page)
  /v1/users/{user_id}/guides/messages/{message_id}/interacted:
    put:
      callbacks: {}
      description: Records that a user has interacted with a guide, triggering any associated interacted events.
      operationId: markUserGuideAsInteracted
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The unique identifier for the message.
          in: path
          name: message_id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/GuideActionRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GuideActionResponse'
          description: OK
      summary: Mark guide as interacted
      tags:
        - Guides
        - Users
  /v1/objects/{collection}/{object_id}/channel_data/{channel_id}:
    delete:
      callbacks: {}
      description: Unsets the channel data for the specified object and channel.
      operationId: unsetObjectChannelData
      parameters:
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: The unique identifier for the channel.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
      responses:
        '204':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EmptyContentResponse'
          description: No Content
      summary: Unset channel data
      tags:
        - Channel data
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.objects.unsetChannelData(
              'collection',
              'object_id',
              '182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e',
            );

            console.log(response);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.objects.unset_channel_data(
              collection="collection",
              object_id="object_id",
              channel_id="182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
          )
          print(response)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Objects.UnsetChannelData(
              context.TODO(),
              "collection",
              "object_id",
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectUnsetChannelDataParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectUnsetChannelDataParams params = ObjectUnsetChannelDataParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .channelId("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .build();
                  String response = client.objects().unsetChannelData(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          response = knock.objects.unset_channel_data("collection", "object_id",
          "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")


          puts(response)
    get:
      callbacks: {}
      description: Returns the channel data for the specified object and channel.
      operationId: getObjectChannelData
      parameters:
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: The unique identifier for the channel.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChannelData'
          description: OK
      summary: Get channel data
      tags:
        - Channel data
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const channelData = await client.objects.getChannelData(
              'collection',
              'object_id',
              '182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e',
            );

            console.log(channelData.channel_id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          channel_data = client.objects.get_channel_data(
              collection="collection",
              object_id="object_id",
              channel_id="182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
          )
          print(channel_data.channel_id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            channelData, err := client.Objects.GetChannelData(
              context.TODO(),
              "collection",
              "object_id",
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", channelData.ChannelID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectGetChannelDataParams;
          import app.knock.api.models.recipients.channeldata.ChannelData;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectGetChannelDataParams params = ObjectGetChannelDataParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .channelId("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .build();
                  ChannelData channelData = client.objects().getChannelData(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          channel_data = knock.objects.get_channel_data("collection", "object_id",
          "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")


          puts(channel_data)
    put:
      callbacks: {}
      description: Sets the channel data for the specified object and channel.
      operationId: setObjectChannelData
      parameters:
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: The unique identifier for the channel.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ChannelDataRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChannelData'
          description: OK
      summary: Set channel data
      tags:
        - Channel data
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const channelData = await client.objects.setChannelData(
              'collection',
              'object_id',
              '182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e',
              { data: { __typename: 'PushChannelData', tokens: ['push_token_1'] } },
            );

            console.log(channelData.channel_id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          channel_data = client.objects.set_channel_data(
              collection="collection",
              object_id="object_id",
              channel_id="182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
              data={
                  "_typename": "PushChannelData",
                  "tokens": ["push_token_1"],
              },
          )
          print(channel_data.channel_id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            channelData, err := client.Objects.SetChannelData(
              context.TODO(),
              "collection",
              "object_id",
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
              knock.ObjectSetChannelDataParams{
                ChannelDataRequest: knock.ChannelDataRequestParam{
                  Data: knock.F[knock.ChannelDataRequestDataUnionParam](knock.PushChannelDataParam{
                    Typename: knock.F(knock.PushChannelData_TypenamePushChannelData),
                    Tokens: knock.F([]string{"push_token_1"}),
                  }),
                },
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", channelData.ChannelID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectSetChannelDataParams;
          import app.knock.api.models.recipients.channeldata.ChannelData;
          import app.knock.api.models.recipients.channeldata.ChannelDataRequest;
          import app.knock.api.models.recipients.channeldata.PushChannelData;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectSetChannelDataParams params = ObjectSetChannelDataParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .channelId("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .channelDataRequest(ChannelDataRequest.builder()
                          .data(PushChannelData.builder()
                              ._typename(PushChannelData._Typename.PUSH_CHANNEL_DATA)
                              .addToken("push_token_1")
                              .build())
                          .build())
                      .build();
                  ChannelData channelData = client.objects().setChannelData(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          channel_data = knock.objects.set_channel_data(
            "collection",
            "object_id",
            "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
            data: {__typename: :PushChannelData, tokens: ["push_token_1"]}
          )

          puts(channel_data)
  /v1/audiences/{key}/members:
    delete:
      callbacks: {}
      description: Removes one or more members from the specified audience.
      operationId: removeAudienceMembers
      parameters:
        - description: The key of the audience.
          in: path
          name: key
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RemoveAudienceMembersRequest'
        description: Params
        required: true
      responses:
        '204':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EmptyContentResponse'
          description: No Content
      summary: Remove members
      tags:
        - Audiences
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.audiences.removeMembers('key', { members: [{ user: { id: 'user_1' } }] });

            console.log(response);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.audiences.remove_members(
              key="key",
              members=[{
                  "user": {
                      "id": "user_1"
                  }
              }],
          )
          print(response)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Audiences.RemoveMembers(
              context.TODO(),
              "key",
              knock.AudienceRemoveMembersParams{
                Members: knock.F([]knock.AudienceRemoveMembersParamsMember{knock.AudienceRemoveMembersParamsMember{
                  User: knock.F(knock.InlineIdentifyUserRequestParam{
                    ID: knock.F("user_1"),
                  }),
                }}),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.audiences.AudienceRemoveMembersParams;
          import app.knock.api.models.users.InlineIdentifyUserRequest;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  AudienceRemoveMembersParams params = AudienceRemoveMembersParams.builder()
                      .key("key")
                      .addMember(AudienceRemoveMembersParams.Member.builder()
                          .user(InlineIdentifyUserRequest.builder()
                              .id("user_1")
                              .build())
                          .build())
                      .build();
                  String response = client.audiences().removeMembers(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.audiences.remove_members("key", members: [{user: {id: "user_1"}}])

          puts(response)
    get:
      callbacks: {}
      description: Returns a paginated list of members for the specified audience.
      operationId: listAudienceMembers
      parameters:
        - description: The key of the audience.
          in: path
          name: key
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListAudienceMembersResponse'
          description: OK
      summary: List members
      tags:
        - Audiences
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.audiences.listMembers('key');

            console.log(response.entries);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.audiences.list_members(
              "key",
          )
          print(response.entries)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Audiences.ListMembers(context.TODO(), "key")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response.Entries)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.audiences.AudienceListMembersParams;
          import app.knock.api.models.audiences.AudienceListMembersResponse;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  AudienceListMembersParams params = AudienceListMembersParams.builder()
                      .key("key")
                      .build();
                  AudienceListMembersResponse response = client.audiences().listMembers(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.audiences.list_members("key")

          puts(response)
    post:
      callbacks: {}
      description: Adds one or more members to the specified audience.
      operationId: addAudienceMembers
      parameters:
        - description: The key of the audience.
          in: path
          name: key
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AddAudienceMembersRequest'
        description: Params
        required: true
      responses:
        '204':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EmptyContentResponse'
          description: No Content
      summary: Add members
      tags:
        - Audiences
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.audiences.addMembers('key', { members: [{ user: { id: 'user_1' } }] });

            console.log(response);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.audiences.add_members(
              key="key",
              members=[{
                  "user": {
                      "id": "user_1"
                  }
              }],
          )
          print(response)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Audiences.AddMembers(
              context.TODO(),
              "key",
              knock.AudienceAddMembersParams{
                Members: knock.F([]knock.AudienceAddMembersParamsMember{knock.AudienceAddMembersParamsMember{
                  User: knock.F(knock.InlineIdentifyUserRequestParam{
                    ID: knock.F("user_1"),
                  }),
                }}),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.audiences.AudienceAddMembersParams;
          import app.knock.api.models.users.InlineIdentifyUserRequest;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  AudienceAddMembersParams params = AudienceAddMembersParams.builder()
                      .key("key")
                      .addMember(AudienceAddMembersParams.Member.builder()
                          .user(InlineIdentifyUserRequest.builder()
                              .id("user_1")
                              .build())
                          .build())
                      .build();
                  String response = client.audiences().addMembers(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.audiences.add_members("key", members: [{user: {id: "user_1"}}])

          puts(response)
  /v1/providers/ms-teams/{channel_id}/channels:
    get:
      callbacks: {}
      description: >-
        List the Microsoft Teams channels within a team. By default, archived and private channels are
        excluded from the results.
      operationId: listChannelsForMsTeamsProvider
      parameters:
        - description: The ID of the Knock Microsoft Teams channel to get channels for.
          in: path
          name: channel_id
          required: true
          schema:
            type: string
        - description: A JSON encoded string containing the Microsoft Teams tenant object reference.
          example: '{"collection":"projects","object_id":"project_123"}'
          in: query
          name: ms_teams_tenant_object
          required: true
          schema:
            type: string
        - description: Microsoft Teams team ID.
          in: query
          name: team_id
          required: true
          schema:
            type: string
        - description: >-
            [OData param](https://learn.microsoft.com/en-us/graph/query-parameters) passed to the Microsoft
            Graph API to filter channels.
          example: displayName eq 'General'
          in: query
          name: query_options.$filter
          required: false
          schema:
            type: string
        - description: >-
            [OData param](https://learn.microsoft.com/en-us/graph/query-parameters) passed to the Microsoft
            Graph API to select specific properties.
          example: id,displayName,description
          in: query
          name: query_options.$select
          required: false
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChannelsForMsTeamsProviderResponse'
          description: OK
      summary: List channels
      tags:
        - Providers
        - Microsoft Teams
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.providers.msTeams.listChannels('channel_id', {
              ms_teams_tenant_object: 'ms_teams_tenant_object',
              team_id: 'team_id',
            });

            console.log(response.ms_teams_channels);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.providers.ms_teams.list_channels(
              channel_id="channel_id",
              ms_teams_tenant_object="ms_teams_tenant_object",
              team_id="team_id",
          )
          print(response.ms_teams_channels)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Providers.MsTeams.ListChannels(
              context.TODO(),
              "channel_id",
              knock.ProviderMsTeamListChannelsParams{
                MsTeamsTenantObject: knock.F("ms_teams_tenant_object"),
                TeamID: knock.F("team_id"),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response.MsTeamsChannels)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.providers.msteams.MsTeamListChannelsParams;
          import app.knock.api.models.providers.msteams.MsTeamListChannelsResponse;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MsTeamListChannelsParams params = MsTeamListChannelsParams.builder()
                      .channelId("channel_id")
                      .msTeamsTenantObject("ms_teams_tenant_object")
                      .teamId("team_id")
                      .build();
                  MsTeamListChannelsResponse response = client.providers().msTeams().listChannels(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.providers.ms_teams.list_channels(
            "channel_id",
            ms_teams_tenant_object: "ms_teams_tenant_object",
            team_id: "team_id"
          )

          puts(response)
  /v1/users/bulk/delete:
    post:
      callbacks: {}
      description: >-
        Deletes multiple users in a single operation. Accepts up to 100 user IDs to delete and returns a bulk
        operation that can be queried for progress.
      operationId: bulkDeleteUsers
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BulkDeleteUsersRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Bulk delete users
      tags:
        - Users
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.users.bulk.delete({ user_ids: ['user_1', 'user_2'] });

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.users.bulk.delete(
              user_ids=["user_1", "user_2"],
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.Users.Bulk.Delete(context.TODO(), knock.UserBulkDeleteParams{
              UserIDs: knock.F([]string{"user_1", "user_2"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.users.bulk.BulkDeleteParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkDeleteParams params = BulkDeleteParams.builder()
                      .addUserId("user_1")
                      .addUserId("user_2")
                      .build();
                  BulkOperation bulkOperation = client.users().bulk().delete(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          bulk_operation = knock.users.bulk.delete(user_ids: ["user_1", "user_2"])

          puts(bulk_operation)
  /v1/objects/{collection}/{object_id}/preferences/{preference_set_id}/workflows/{key}:
    put:
      callbacks: {}
      deprecated: true
      description: Updates a specific workflow preference for an object's preference set.
      operationId: updateObjectPreferenceWorkflow
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update a workflow preference
      tags:
        - Objects
        - Preferences
  /v1/providers/slack/{channel_id}/revoke_access:
    put:
      callbacks: {}
      description: Revoke access for a Slack channel.
      operationId: slackProviderRevokeAccess
      parameters:
        - description: The ID of the Knock Slack channel to revoke access for.
          in: path
          name: channel_id
          required: true
          schema:
            type: string
        - description: A JSON encoded string containing the access token object reference.
          example: '{"collection":"projects","object_id":"project_123"}'
          in: query
          name: access_token_object
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                example: ok
                type: string
          description: OK
      summary: Revoke access
      tags:
        - Providers
        - Slack
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.providers.slack.revokeAccess('channel_id', {
              access_token_object: 'access_token_object',
            });

            console.log(response);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.providers.slack.revoke_access(
              channel_id="channel_id",
              access_token_object="access_token_object",
          )
          print(response)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Providers.Slack.RevokeAccess(
              context.TODO(),
              "channel_id",
              knock.ProviderSlackRevokeAccessParams{
                AccessTokenObject: knock.F("access_token_object"),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.providers.slack.SlackRevokeAccessParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  SlackRevokeAccessParams params = SlackRevokeAccessParams.builder()
                      .channelId("channel_id")
                      .accessTokenObject("access_token_object")
                      .build();
                  String response = client.providers().slack().revokeAccess(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          response = knock.providers.slack.revoke_access("channel_id", access_token_object:
          "access_token_object")


          puts(response)
  /v1/messages/batch/unread:
    post:
      callbacks: {}
      description: Marks the given messages as unread.
      operationId: batchMarkMessagesAsUnread
      parameters:
        - description: The message IDs to update the status of.
          in: body
          name: message_ids
          required: true
          schema:
            items:
              format: uuid
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                description: The list of messages that were updated
                example:
                  - actors:
                      - user_123
                    archived_at: null
                    channel_id: 123e4567-e89b-12d3-a456-426614174000
                    clicked_at: null
                    data:
                      foo: bar
                    engagement_statuses:
                      - read
                      - seen
                    id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
                    inserted_at: '2021-01-01T00:00:00Z'
                    interacted_at: null
                    link_clicked_at: null
                    metadata:
                      external_id: 123e4567-e89b-12d3-a456-426614174000
                    read_at: null
                    recipient: user_123
                    scheduled_at: null
                    seen_at: null
                    source:
                      __typename: NotificationSource
                      categories:
                        - collaboration
                      key: comment-created
                      version_id: 123e4567-e89b-12d3-a456-426614174000
                    status: sent
                    tenant: tenant_123
                    updated_at: '2021-01-01T00:00:00Z'
                    workflow: comment-created
                items:
                  $ref: '#/components/schemas/Message'
                title: BatchListMessagesResponse
                type: array
          description: OK
      summary: Mark messages as unread
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const messages = await client.messages.batch.markAsUnread({
              message_ids: ['182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e'],
            });

            console.log(messages);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          messages = client.messages.batch.mark_as_unread(
              message_ids=["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"],
          )
          print(messages)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            messages, err := client.Messages.Batch.MarkAsUnread(context.TODO(), knock.MessageBatchMarkAsUnreadParams{
              MessageIDs: knock.F([]string{"182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", messages)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.batch.BatchMarkAsUnreadParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  List<Message> messages = client.messages().batch().markAsUnread();
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          messages = knock.messages.batch.mark_as_unread(message_ids:
          ["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"])


          puts(messages)
  /v1/objects/{collection}:
    get:
      callbacks: {}
      description: >-
        Returns a paginated list of objects from the specified collection. Optionally includes preference data
        for the objects.
      operationId: listObjects
      parameters:
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: Includes preferences of the objects in the response.
          in: query
          name: include[]
          required: false
          schema:
            items:
              enum:
                - preferences
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListObjectsResponse'
          description: OK
      summary: List objects in a collection
      tags:
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const object of client.objects.list('collection')) {
              console.log(object.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.objects.list(
              collection="collection",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Objects.List(
              context.TODO(),
              "collection",
              knock.ObjectListParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectListPage;
          import app.knock.api.models.objects.ObjectListParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectListParams params = ObjectListParams.builder()
                      .collection("collection")
                      .build();
                  ObjectListPage page = client.objects().list(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.objects.list("collection")

          puts(page)
  /v1/objects/{collection}/{object_id}/preferences/{preference_set_id}/workflows:
    put:
      callbacks: {}
      deprecated: true
      description: Updates the workflow preferences for an object's preference set.
      operationId: updateObjectPreferenceWorkflows
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update workflows in preference set
      tags:
        - Objects
        - Preferences
  /v1/users/{user_id}/preferences:
    get:
      callbacks: {}
      description: Retrieves a list of all preference sets for a specific user.
      operationId: listUserPreferenceSets
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                description: A list of preference sets for the user.
                example:
                  - __typename: PreferenceSet
                    categories:
                      marketing: false
                      transactional:
                        channel_types:
                          email: false
                    channel_types:
                      email: true
                      push: false
                      sms:
                        conditions:
                          - argument: US
                            operator: equal_to
                            variable: recipient.country_code
                    id: default
                    workflows: null
                items:
                  $ref: '#/components/schemas/PreferenceSet'
                title: ListUserPreferenceSetsResponse
                type: array
          description: OK
      summary: List preference sets
      tags:
        - Users
        - Preferences
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const preferenceSets = await client.users.listPreferences('user_id');

            console.log(preferenceSets);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          preference_sets = client.users.list_preferences(
              "user_id",
          )
          print(preference_sets)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            preferenceSets, err := client.Users.ListPreferences(context.TODO(), "user_id")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", preferenceSets)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.recipients.preferences.PreferenceSet;
          import app.knock.api.models.users.UserListPreferencesParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserListPreferencesParams params = UserListPreferencesParams.builder()
                      .userId("user_id")
                      .build();
                  List<PreferenceSet> preferenceSets = client.users().listPreferences(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          preference_sets = knock.users.list_preferences("user_id")

          puts(preference_sets)
  /v1/users/{user_id}/schedules:
    get:
      callbacks: {}
      description: Returns a paginated list of schedules for a specific user. Can be filtered by workflow and tenant.
      operationId: listUserSchedules
      parameters:
        - description: The ID of the user to list schedules for.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The ID of the workflow to list schedules for.
          in: query
          name: workflow
          required: false
          schema:
            type: string
        - description: The ID of the tenant to list schedules for.
          in: query
          name: tenant
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListSchedulesResponse'
          description: OK
      summary: List schedules
      tags:
        - Schedules
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const schedule of client.users.listSchedules('user_id')) {
              console.log(schedule.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.users.list_schedules(
              user_id="user_id",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Users.ListSchedules(
              context.TODO(),
              "user_id",
              knock.UserListSchedulesParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.UserListSchedulesPage;
          import app.knock.api.models.users.UserListSchedulesParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserListSchedulesParams params = UserListSchedulesParams.builder()
                      .userId("user_id")
                      .build();
                  UserListSchedulesPage page = client.users().listSchedules(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.users.list_schedules("user_id")

          puts(page)
  /v1/users/{user_id}/guides/messages/{message_id}/archived:
    put:
      callbacks: {}
      description: Records that a guide has been archived by a user, triggering any associated archived events.
      operationId: markUserGuideAsArchived
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The unique identifier for the message.
          in: path
          name: message_id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/GuideActionRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GuideActionResponse'
          description: OK
      summary: Mark guide as archived
      tags:
        - Guides
        - Users
  /v1/messages/{message_id}/archived:
    delete:
      callbacks: {}
      description: Removes a message from the archived state, making it visible in the default message list again.
      operationId: unarchiveMessage (2)
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Unarchive message
      tags:
        - Messages
    put:
      callbacks: {}
      description: >-
        Archives a message for the current user. Archived messages are hidden from the default message list
        but can still be accessed and unarchived later.
      operationId: archiveMessage
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Archive message
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const message = await client.messages.archive('1jNaXzB2RZX3LY8wVQnfCKyPnv7');

            console.log(message.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          message = client.messages.archive(
              "message_id",
          )
          print(message.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            message, err := client.Messages.Archive(context.TODO(), "1jNaXzB2RZX3LY8wVQnfCKyPnv7")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", message.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.MessageArchiveParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageArchiveParams params = MessageArchiveParams.builder()
                      .messageId("1jNaXzB2RZX3LY8wVQnfCKyPnv7")
                      .build();
                  Message message = client.messages().archive(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          message = knock.messages.archive("message_id")

          puts(message)
  /v1/messages/batch/archived:
    post:
      callbacks: {}
      description: Marks the given messages as archived.
      operationId: batchMarkMessagesAsArchived
      parameters:
        - description: The message IDs to update the status of.
          in: body
          name: message_ids
          required: true
          schema:
            items:
              format: uuid
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                description: The list of messages that were updated
                example:
                  - actors:
                      - user_123
                    archived_at: null
                    channel_id: 123e4567-e89b-12d3-a456-426614174000
                    clicked_at: null
                    data:
                      foo: bar
                    engagement_statuses:
                      - read
                      - seen
                    id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
                    inserted_at: '2021-01-01T00:00:00Z'
                    interacted_at: null
                    link_clicked_at: null
                    metadata:
                      external_id: 123e4567-e89b-12d3-a456-426614174000
                    read_at: null
                    recipient: user_123
                    scheduled_at: null
                    seen_at: null
                    source:
                      __typename: NotificationSource
                      categories:
                        - collaboration
                      key: comment-created
                      version_id: 123e4567-e89b-12d3-a456-426614174000
                    status: sent
                    tenant: tenant_123
                    updated_at: '2021-01-01T00:00:00Z'
                    workflow: comment-created
                items:
                  $ref: '#/components/schemas/Message'
                title: BatchListMessagesResponse
                type: array
          description: OK
      summary: Mark messages as archived
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const messages = await client.messages.batch.archive({
              message_ids: ['182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e'],
            });

            console.log(messages);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          messages = client.messages.batch.archive(
              message_ids=["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"],
          )
          print(messages)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            messages, err := client.Messages.Batch.Archive(context.TODO(), knock.MessageBatchArchiveParams{
              MessageIDs: knock.F([]string{"182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", messages)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.batch.BatchArchiveParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  List<Message> messages = client.messages().batch().archive();
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          messages = knock.messages.batch.archive(message_ids: ["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"])

          puts(messages)
  /v1/users/{user_id}/feeds/{channel_id}/settings:
    get:
      callbacks: {}
      description: Returns the feed settings for a user.
      operationId: getUserInAppFeedSettings
      parameters:
        - description: The ID for the user that you set when identifying them in Knock.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The unique identifier for the channel.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserInAppFeedSettingsResponse'
          description: OK
      summary: Get feed settings
      tags:
        - Feeds
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.users.feeds.getSettings('user_id', '182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e');

            console.log(response.features);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.users.feeds.get_settings(
              user_id="user_id",
              channel_id="182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
          )
          print(response.features)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Users.Feeds.GetSettings(
              context.TODO(),
              "user_id",
              "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response.Features)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.feeds.FeedGetSettingsParams;
          import app.knock.api.models.users.feeds.FeedGetSettingsResponse;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  FeedGetSettingsParams params = FeedGetSettingsParams.builder()
                      .userId("user_id")
                      .channelId("182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")
                      .build();
                  FeedGetSettingsResponse response = client.users().feeds().getSettings(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.users.feeds.get_settings("user_id", "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e")

          puts(response)
  /v1/users/{user_id}/messages:
    get:
      callbacks: {}
      description: >-
        Returns a paginated list of messages for a specific user. Allows filtering by message status and
        provides various sorting options.
      operationId: listMessagesForUser
      parameters:
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
        - description: Limits the results to items with the corresponding tenant, or where the tenant is empty.
          example: tenant_123
          in: query
          name: tenant
          required: false
          schema:
            type: string
        - description: Limits the results to items with the corresponding channel id.
          example: 123e4567-e89b-12d3-a456-426614174000
          in: query
          name: channel_id
          required: false
          schema:
            type: string
        - description: One or more delivery statuses. Limits results to messages with the given delivery status(es).
          example:
            - delivered
          in: query
          name: status[]
          required: false
          schema:
            items:
              enum:
                - queued
                - sent
                - delivered
                - delivery_attempted
                - undelivered
                - not_sent
                - bounced
              type: string
            type: array
        - description: One or more engagement statuses. Limits results to messages with the given engagement status(es).
          example:
            - unread
          in: query
          name: engagement_status[]
          required: false
          schema:
            items:
              enum:
                - seen
                - read
                - interacted
                - link_clicked
                - archived
              type: string
            type: array
        - description: >-
            Limits the results to only the message ids given (max 50). Note: when using this option, the
            results will be subject to any other filters applied to the query.
          example:
            - 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: query
          name: message_ids[]
          required: false
          schema:
            items:
              type: string
            type: array
        - description: Limits the results to only items related to any of the provided categories.
          example:
            - workflow_123
          in: query
          name: workflow_categories[]
          required: false
          schema:
            items:
              type: string
            type: array
        - description: Key of the source that triggered the message to limit results to.
          example: comment-created
          in: query
          name: source
          required: false
          schema:
            type: string
        - description: Limits the results to messages triggered by the top-level workflow run ID.
          example: 123e4567-e89b-12d3-a456-426614174000
          in: query
          name: workflow_run_id
          required: false
          schema:
            format: uuid
            type: string
        - description: Limits the results to messages for a specific recipient's workflow run.
          example: 123e4567-e89b-12d3-a456-426614174000
          in: query
          name: workflow_recipient_run_id
          required: false
          schema:
            format: uuid
            type: string
        - description: Limits the results to only items that were generated with the given data.
          example: '{"comment_id": "123"}'
          in: query
          name: trigger_data
          required: false
          schema:
            type: string
        - description: The user ID to list messages for.
          example: user-123
          in: path
          name: user_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListMessagesResponse'
          description: OK
      summary: List messages
      tags:
        - Messages
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const message of client.users.listMessages('user-123')) {
              console.log(message.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.users.list_messages(
              user_id="user-123",
          )
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Users.ListMessages(
              context.TODO(),
              "user-123",
              knock.UserListMessagesParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.UserListMessagesPage;
          import app.knock.api.models.users.UserListMessagesParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserListMessagesParams params = UserListMessagesParams.builder()
                      .userId("user-123")
                      .build();
                  UserListMessagesPage page = client.users().listMessages(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.users.list_messages("user_id")

          puts(page)
  /v1/integrations/hightouch/embedded-destination:
    post:
      callbacks: {}
      description: Processes a Hightouch embedded destination RPC request.
      operationId: processHightouchRpcRequest
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              properties:
                id:
                  description: The unique identifier for the RPC request.
                  type: string
                jsonrpc:
                  description: The JSON-RPC version.
                  type: string
                method:
                  description: The method name to execute.
                  type: string
                params:
                  description: The parameters for the method.
                  type: object
              required:
                - id
                - method
                - jsonrpc
              type: object
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                properties:
                  id:
                    description: The request ID.
                    type: string
                  result:
                    description: The result of the RPC call.
                    type: object
                type: object
          description: OK
      summary: Process a Hightouch RPC request
      tags:
        - Integrations
  /v1/messages/{message_id}/interacted:
    put:
      callbacks: {}
      description: >-
        Marks a message as interacted with by the current user. This can include any user action on the
        message, with optional metadata about the specific interaction.
      operationId: markMessageInteracted
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MessageInteractedRequest'
        description: Params
        required: false
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Mark message as interacted
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const message = await client.messages.markAsInteracted('1jNaXzB2RZX3LY8wVQnfCKyPnv7');

            console.log(message.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          message = client.messages.mark_as_interacted(
              message_id="1jNaXzB2RZX3LY8wVQnfCKyPnv7",
          )
          print(message.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            message, err := client.Messages.MarkAsInteracted(
              context.TODO(),
              "1jNaXzB2RZX3LY8wVQnfCKyPnv7",
              knock.MessageMarkAsInteractedParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", message.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.MessageMarkAsInteractedParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageMarkAsInteractedParams params = MessageMarkAsInteractedParams.builder()
                      .messageId("1jNaXzB2RZX3LY8wVQnfCKyPnv7")
                      .build();
                  Message message = client.messages().markAsInteracted(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          message = knock.messages.mark_as_interacted("message_id")

          puts(message)
  /v1/users/{user_id}/preferences/{preference_set_id}/channel_types:
    put:
      callbacks: {}
      deprecated: true
      description: Updates the channel types in a specific user preference set. This operation is deprecated.
      operationId: updateUserPreferenceChannelTypes
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update channel types in preference set
      tags:
        - Users
        - Preferences
  /v1/objects/{collection}/{object_id}/preferences/{preference_set_id}/categories/{key}:
    put:
      callbacks: {}
      deprecated: true
      description: Updates a specific category preference for an object's preference set. Deprecated.
      operationId: updateObjectPreferenceCategory
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update a category preference
      tags:
        - Objects
        - Preferences
  /v1/messages/{message_id}/unarchived:
    delete:
      callbacks: {}
      description: Removes a message from the archived state, making it visible in the default message list again.
      operationId: unarchiveMessage
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Unarchive message
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const message = await client.messages.unarchive('1jNaXzB2RZX3LY8wVQnfCKyPnv7');

            console.log(message.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          message = client.messages.unarchive(
              "message_id",
          )
          print(message.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            message, err := client.Messages.Unarchive(context.TODO(), "1jNaXzB2RZX3LY8wVQnfCKyPnv7")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", message.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.MessageUnarchiveParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageUnarchiveParams params = MessageUnarchiveParams.builder()
                      .messageId("1jNaXzB2RZX3LY8wVQnfCKyPnv7")
                      .build();
                  Message message = client.messages().unarchive(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          message = knock.messages.unarchive("message_id")

          puts(message)
  /v1/users/{user_id}/in-app-messages/{channel_id}/{message_type}:
    get:
      callbacks: {}
      description: Returns a paginated list of in-app messages for a specific user and channel type.
      operationId: getUserInAppMessages
      parameters:
        - description: The user ID.
          in: path
          name: user_id
          required: true
          schema:
            type: string
        - description: The channel ID.
          in: path
          name: channel_id
          required: true
          schema:
            format: uuid
            type: string
        - description: The type of in-app messages to retrieve.
          in: query
          name: message_type
          required: true
          schema:
            type: string
        - description: The tenant ID to filter messages by.
          in: query
          name: tenant
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                additionalProperties: true
                type: object
          description: OK
      summary: List in-app messages
      tags:
        - In-app messages
        - Users
  /v1/users/{user_id}/preferences/{preference_set_id}/categories:
    put:
      callbacks: {}
      deprecated: true
      description: Updates the categories in a specific user preference set. This operation is deprecated.
      operationId: updateUserPreferenceCategories
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update categories in preference set
      tags:
        - Users
        - Preferences
  /v1/users:
    get:
      callbacks: {}
      description: Retrieve a paginated list of users in the environment.
      operationId: listUsers
      parameters:
        - description: Associated resources to include in the response.
          in: query
          name: include[]
          required: false
          schema:
            items:
              enum:
                - preferences
              type: string
            type: array
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListUsersResponse'
          description: OK
      summary: List users
      tags:
        - Users
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const user of client.users.list()) {
              console.log(user.id);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.users.list()
          page = page.entries[0]
          print(page.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Users.List(context.TODO(), knock.UserListParams{

            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.users.UserListPage;
          import app.knock.api.models.users.UserListParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  UserListPage page = client.users().list();
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.users.list

          puts(page)
  /v1/notify:
    post:
      callbacks: {}
      description: Triggers a workflow with the given key, actor, recipients, and optional data.
      operationId: triggerWorkflow
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Notify Request'
        description: Notify Payload
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Notify Response'
          description: OK
      summary: Trigger workflow
      tags:
        - Workflow Triggers
  /v1/providers/ms-teams/{channel_id}/teams:
    get:
      callbacks: {}
      description: >-
        Get a list of teams belonging to the Microsoft Entra tenant. By default, archived and private channels
        are excluded from the results.
      operationId: listTeamsForMsTeamsProvider
      parameters:
        - description: The ID of the Knock Microsoft Teams channel to get teams for.
          in: path
          name: channel_id
          required: true
          schema:
            type: string
        - description: A JSON encoded string containing the Microsoft Teams tenant object reference.
          example: '{"collection":"projects","object_id":"project_123"}'
          in: query
          name: ms_teams_tenant_object
          required: true
          schema:
            type: string
        - description: >-
            [OData param](https://learn.microsoft.com/en-us/graph/query-parameters) passed to the Microsoft
            Graph API to filter teams.
          example: displayName eq 'My Team'
          in: query
          name: query_options.$filter
          required: false
          schema:
            type: string
        - description: >-
            [OData param](https://learn.microsoft.com/en-us/graph/query-parameters) passed to the Microsoft
            Graph API to select fields on a team.
          example: id,displayName,description
          in: query
          name: query_options.$select
          required: false
          schema:
            type: string
        - description: >-
            [OData param](https://learn.microsoft.com/en-us/graph/query-parameters) passed to the Microsoft
            Graph API to limit the number of teams returned.
          example: 10
          in: query
          name: query_options.$top
          required: false
          schema:
            type: integer
        - description: >-
            [OData param](https://learn.microsoft.com/en-us/graph/query-parameters) passed to the Microsoft
            Graph API to retrieve the next page of results.
          in: query
          name: query_options.$skiptoken
          required: false
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TeamsForMsTeamsProviderResponse'
          description: OK
      summary: List teams
      tags:
        - Providers
        - Microsoft Teams
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.providers.msTeams.listTeams('channel_id', {
              ms_teams_tenant_object: 'ms_teams_tenant_object',
            });

            console.log(response.ms_teams_teams);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.providers.ms_teams.list_teams(
              channel_id="channel_id",
              ms_teams_tenant_object="ms_teams_tenant_object",
          )
          print(response.ms_teams_teams)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Providers.MsTeams.ListTeams(
              context.TODO(),
              "channel_id",
              knock.ProviderMsTeamListTeamsParams{
                MsTeamsTenantObject: knock.F("ms_teams_tenant_object"),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response.MsTeamsTeams)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.providers.msteams.MsTeamListTeamsParams;
          import app.knock.api.models.providers.msteams.MsTeamListTeamsResponse;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MsTeamListTeamsParams params = MsTeamListTeamsParams.builder()
                      .channelId("channel_id")
                      .msTeamsTenantObject("ms_teams_tenant_object")
                      .build();
                  MsTeamListTeamsResponse response = client.providers().msTeams().listTeams(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          response = knock.providers.ms_teams.list_teams("channel_id", ms_teams_tenant_object:
          "ms_teams_tenant_object")


          puts(response)
  /v1/messages/batch/read:
    post:
      callbacks: {}
      description: Marks the given messages as read.
      operationId: batchMarkMessagesAsRead
      parameters:
        - description: The message IDs to update the status of.
          in: body
          name: message_ids
          required: true
          schema:
            items:
              format: uuid
              type: string
            type: array
      responses:
        '200':
          content:
            application/json:
              schema:
                description: The list of messages that were updated
                example:
                  - actors:
                      - user_123
                    archived_at: null
                    channel_id: 123e4567-e89b-12d3-a456-426614174000
                    clicked_at: null
                    data:
                      foo: bar
                    engagement_statuses:
                      - read
                      - seen
                    id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
                    inserted_at: '2021-01-01T00:00:00Z'
                    interacted_at: null
                    link_clicked_at: null
                    metadata:
                      external_id: 123e4567-e89b-12d3-a456-426614174000
                    read_at: null
                    recipient: user_123
                    scheduled_at: null
                    seen_at: null
                    source:
                      __typename: NotificationSource
                      categories:
                        - collaboration
                      key: comment-created
                      version_id: 123e4567-e89b-12d3-a456-426614174000
                    status: sent
                    tenant: tenant_123
                    updated_at: '2021-01-01T00:00:00Z'
                    workflow: comment-created
                items:
                  $ref: '#/components/schemas/Message'
                title: BatchListMessagesResponse
                type: array
          description: OK
      summary: Mark messages as read
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const messages = await client.messages.batch.markAsRead({
              message_ids: ['182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e'],
            });

            console.log(messages);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          messages = client.messages.batch.mark_as_read(
              message_ids=["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"],
          )
          print(messages)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            messages, err := client.Messages.Batch.MarkAsRead(context.TODO(), knock.MessageBatchMarkAsReadParams{
              MessageIDs: knock.F([]string{"182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", messages)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.batch.BatchMarkAsReadParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  List<Message> messages = client.messages().batch().markAsRead();
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          messages = knock.messages.batch.mark_as_read(message_ids: ["182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"])

          puts(messages)
  /v1/workflows/{key}/cancel:
    post:
      callbacks: {}
      description: >-
        When invoked for a workflow using a specific workflow key and cancellation key, will cancel any queued
        workflow runs associated with that key/cancellation key pair. Can optionally be provided one or more
        recipients to scope the request to.
      operationId: cancelWorkflow
      parameters:
        - description: The key of the workflow to cancel.
          in: path
          name: key
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CancelWorkflowRequest'
        description: Params
        required: true
      responses:
        '204':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EmptyContentResponse'
          description: No Content
      summary: Cancel workflow
      tags:
        - Workflows
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.workflows.cancel('key', { cancellation_key: 'cancel-workflow-123' });

            console.log(response);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.workflows.cancel(
              key="key",
              cancellation_key="cancel-workflow-123",
          )
          print(response)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Workflows.Cancel(
              context.TODO(),
              "key",
              knock.WorkflowCancelParams{
                CancellationKey: knock.F("cancel-workflow-123"),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.workflows.WorkflowCancelParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  WorkflowCancelParams params = WorkflowCancelParams.builder()
                      .key("key")
                      .cancellationKey("cancel-workflow-123")
                      .build();
                  String response = client.workflows().cancel(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          response = knock.workflows.cancel("key", cancellation_key: "cancel-workflow-123")

          puts(response)
  /v1/schedules/bulk/create:
    post:
      callbacks: {}
      description: >-
        Creates up to 1000 schedules in a single asynchronous bulk operation. The list of schedules can
        include inline-identifications for each recipient, tenant, and actor specified on a schedule.
      operationId: bulkCreateSchedules
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Create schedules in bulk
      tags:
        - Objects
        - Bulk operations
  /v1/users/{user_id}/preferences/{preference_set_id}/workflows:
    put:
      callbacks: {}
      deprecated: true
      description: Updates the workflows in a specific user preference set. This operation is deprecated.
      operationId: updateUserPreferenceWorkflows
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update workflows in preference set
      tags:
        - Users
        - Preferences
  /v1/tenants/bulk/set:
    post:
      callbacks: {}
      description: >-
        Set or update multiple tenants in a single operation. This operation allows you to create or update
        multiple tenants with their properties and settings.
      operationId: bulkSetTenants
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BulkSetTenantsRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Bulk set tenants
      tags:
        - Tenants
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.tenants.bulk.set({ tenants: ['string'] });

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.tenants.bulk.set(
              tenants=["string"],
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
            "github.com/stainless-sdks/knock-go/shared"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.Tenants.Bulk.Set(context.TODO(), knock.TenantBulkSetParams{
              Tenants: knock.F([]knock.InlineTenantRequestUnionParam{shared.UnionString("string")}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.tenants.bulk.BulkSetParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkSetParams params = BulkSetParams.builder()
                      .addTenant("string")
                      .build();
                  BulkOperation bulkOperation = client.tenants().bulk().set(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          bulk_operation = knock.tenants.bulk.set(tenants: ["string"])

          puts(bulk_operation)
  /v1/tenants/{tenant_id}:
    delete:
      callbacks: {}
      description: Delete a tenant and all associated data. This operation cannot be undone.
      operationId: deleteTenant
      parameters:
        - description: The unique identifier for the tenant.
          in: path
          name: tenant_id
          required: true
          schema:
            type: string
      responses:
        '204':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EmptyContentResponse'
          description: No Content
      summary: Delete a tenant
      tags:
        - Tenants
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const tenant = await client.tenants.delete('tenant_id');

            console.log(tenant);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          tenant = client.tenants.delete(
              "tenant_id",
          )
          print(tenant)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            tenant, err := client.Tenants.Delete(context.TODO(), "tenant_id")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", tenant)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.tenants.TenantDeleteParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  TenantDeleteParams params = TenantDeleteParams.builder()
                      .tenantId("tenant_id")
                      .build();
                  String tenant = client.tenants().delete(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          tenant = knock.tenants.delete("tenant_id")

          puts(tenant)
    get:
      callbacks: {}
      description: Get a tenant by ID.
      operationId: getTenant
      parameters:
        - description: The unique identifier for the tenant.
          in: path
          name: tenant_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Tenant'
          description: OK
      summary: Get a tenant
      tags:
        - Tenants
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const tenant = await client.tenants.get('tenant_id');

            console.log(tenant.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          tenant = client.tenants.get(
              "tenant_id",
          )
          print(tenant.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            tenant, err := client.Tenants.Get(context.TODO(), "tenant_id")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", tenant.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.tenants.Tenant;
          import app.knock.api.models.tenants.TenantGetParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  TenantGetParams params = TenantGetParams.builder()
                      .tenantId("tenant_id")
                      .build();
                  Tenant tenant = client.tenants().get(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          tenant = knock.tenants.get("tenant_id")

          puts(tenant)
    put:
      callbacks: {}
      description: >-
        Set or update a tenant's properties and settings. This operation allows you to update tenant
        preferences, channel data, and branding settings.
      operationId: setTenant
      parameters:
        - description: The unique identifier for the tenant.
          in: path
          name: tenant_id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/SetTenantRequest'
        description: Tenant
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Tenant'
          description: OK
      summary: Set a tenant
      tags:
        - Tenants
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const tenant = await client.tenants.set('tenant_id');

            console.log(tenant.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          tenant = client.tenants.set(
              tenant_id="tenant_id",
          )
          print(tenant.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            tenant, err := client.Tenants.Set(
              context.TODO(),
              "tenant_id",
              knock.TenantSetParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", tenant.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.tenants.Tenant;
          import app.knock.api.models.tenants.TenantSetParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  TenantSetParams params = TenantSetParams.builder()
                      .tenantId("tenant_id")
                      .build();
                  Tenant tenant = client.tenants().set(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          tenant = knock.tenants.set("tenant_id")

          puts(tenant)
  /v1/providers/ms-teams/{channel_id}/revoke_access:
    put:
      callbacks: {}
      description: Remove a Microsoft Entra tenant ID from a Microsoft Teams tenant object.
      operationId: msTeamsProviderRevokeAccess
      parameters:
        - description: The ID of the Knock Microsoft Teams channel to revoke access for.
          in: path
          name: channel_id
          required: true
          schema:
            type: string
        - description: A JSON encoded string containing the Microsoft Teams tenant object reference.
          example: '{"collection":"projects","object_id":"project_123"}'
          in: query
          name: ms_teams_tenant_object
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                example: ok
                type: string
          description: OK
      summary: Revoke access
      tags:
        - Providers
        - Microsoft Teams
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const response = await client.providers.msTeams.revokeAccess('channel_id', {
              ms_teams_tenant_object: 'ms_teams_tenant_object',
            });

            console.log(response);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          response = client.providers.ms_teams.revoke_access(
              channel_id="channel_id",
              ms_teams_tenant_object="ms_teams_tenant_object",
          )
          print(response)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            response, err := client.Providers.MsTeams.RevokeAccess(
              context.TODO(),
              "channel_id",
              knock.ProviderMsTeamRevokeAccessParams{
                MsTeamsTenantObject: knock.F("ms_teams_tenant_object"),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", response)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.providers.msteams.MsTeamRevokeAccessParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MsTeamRevokeAccessParams params = MsTeamRevokeAccessParams.builder()
                      .channelId("channel_id")
                      .msTeamsTenantObject("ms_teams_tenant_object")
                      .build();
                  String response = client.providers().msTeams().revokeAccess(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          response = knock.providers.ms_teams.revoke_access("channel_id", ms_teams_tenant_object:
          "ms_teams_tenant_object")


          puts(response)
  /v1/messages/{message_id}:
    get:
      callbacks: {}
      description: Retrieves a specific message by its ID.
      operationId: getMessage
      parameters:
        - description: The unique identifier for the message.
          example: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
          in: path
          name: message_id
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Message'
          description: OK
      summary: Get message
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const message = await client.messages.get('1jNaXzB2RZX3LY8wVQnfCKyPnv7');

            console.log(message.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          message = client.messages.get(
              "message_id",
          )
          print(message.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            message, err := client.Messages.Get(context.TODO(), "1jNaXzB2RZX3LY8wVQnfCKyPnv7")
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", message.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.MessageGetParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  MessageGetParams params = MessageGetParams.builder()
                      .messageId("1jNaXzB2RZX3LY8wVQnfCKyPnv7")
                      .build();
                  Message message = client.messages().get(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          message = knock.messages.get("message_id")

          puts(message)
  /v1/users/{user_id}/preferences/{preference_set_id}/channel_types/{type}:
    put:
      callbacks: {}
      deprecated: true
      description: Updates a single channel type in a specific user preference set. This operation is deprecated.
      operationId: updateUserPreferenceChannelType
      parameters: []
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PreferenceSet'
          description: OK
      summary: Update channel type in preference set
      tags:
        - Users
        - Preferences
  /v1/objects/{collection}/{object_id}/subscriptions:
    delete:
      callbacks: {}
      description: >-
        Delete subscriptions for the specified recipients from an object. Returns the list of deleted
        subscriptions.
      operationId: deleteSubscriptionsForObject
      parameters:
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DeleteSubscriptionsRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SubscriptionsResponse'
          description: OK
      summary: Delete subscriptions
      tags:
        - Subscriptions
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const subscriptions = await client.objects.deleteSubscriptions('collection', 'object_id', {
              recipients: [{ id: 'user_1' }],
            });

            console.log(subscriptions);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          subscriptions = client.objects.delete_subscriptions(
              collection="collection",
              object_id="object_id",
              recipients=[{
                  "id": "user_1"
              }],
          )
          print(subscriptions)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            subscriptions, err := client.Objects.DeleteSubscriptions(
              context.TODO(),
              "collection",
              "object_id",
              knock.ObjectDeleteSubscriptionsParams{
                Recipients: knock.F([]knock.RecipientRequestUnionParam{knock.InlineIdentifyUserRequestParam{
                  ID: knock.F("user_1"),
                }}),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", subscriptions)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectDeleteSubscriptionsParams;
          import app.knock.api.models.recipients.subscriptions.Subscription;
          import app.knock.api.models.users.InlineIdentifyUserRequest;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectDeleteSubscriptionsParams params = ObjectDeleteSubscriptionsParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .addRecipient(InlineIdentifyUserRequest.builder()
                          .id("user_1")
                          .build())
                      .build();
                  List<Subscription> subscriptions = client.objects().deleteSubscriptions(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          subscriptions = knock.objects.delete_subscriptions("collection", "object_id", recipients: [{id:
          "user_1"}])


          puts(subscriptions)
    get:
      callbacks: {}
      description: >-
        List subscriptions for an object. Either list all subscriptions that belong to the object, or all
        subscriptions that this object has. Determined by the `mode` query parameter.
      operationId: listSubscriptionsForObject
      parameters:
        - description: Mode of the request.
          in: query
          name: mode
          required: false
          schema:
            default: object
            enum:
              - recipient
              - object
            type: string
        - description: Additional fields to include in the response.
          in: query
          name: include[]
          required: false
          schema:
            items:
              enum:
                - preferences
              type: string
            type: array
        - description: Recipients to filter by (only used if mode is `object`).
          in: query
          name: recipients[]
          required: false
          schema:
            items:
              $ref: '#/components/schemas/RecipientReference'
            type: array
        - description: Objects to filter by (only used if mode is `recipient`).
          in: query
          name: objects[]
          required: false
          schema:
            items:
              $ref: '#/components/schemas/RecipientReference'
            type: array
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
        - description: The cursor to fetch entries after.
          in: query
          name: after
          required: false
          schema:
            type: string
        - description: The cursor to fetch entries before.
          in: query
          name: before
          required: false
          schema:
            type: string
        - description: The number of items per page.
          in: query
          name: page_size
          required: false
          schema:
            type: integer
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListSubscriptionsResponse'
          description: OK
      summary: List subscriptions
      tags:
        - Subscriptions
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            // Automatically fetches more pages as needed.
            for await (const subscription of client.objects.listSubscriptions('collection', 'object_id')) {
              console.log(subscription.__typename);
            }
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          page = client.objects.list_subscriptions(
              collection="collection",
              object_id="object_id",
          )
          page = page.entries[0]
          print(page._typename)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            page, err := client.Objects.ListSubscriptions(
              context.TODO(),
              "collection",
              "object_id",
              knock.ObjectListSubscriptionsParams{

              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", page)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectListSubscriptionsPage;
          import app.knock.api.models.objects.ObjectListSubscriptionsParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectListSubscriptionsParams params = ObjectListSubscriptionsParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .build();
                  ObjectListSubscriptionsPage page = client.objects().listSubscriptions(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          page = knock.objects.list_subscriptions("collection", "object_id")

          puts(page)
    post:
      callbacks: {}
      description: Add subscriptions for an object. If a subscription already exists, it will be updated.
      operationId: addSubscriptionsForObject
      parameters:
        - description: Unique identifier for the object.
          in: path
          name: object_id
          required: true
          schema:
            type: string
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpsertSubscriptionsRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SubscriptionsResponse'
          description: OK
      summary: Add subscriptions
      tags:
        - Subscriptions
        - Objects
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const subscriptions = await client.objects.addSubscriptions('collection', 'object_id', {
              recipients: ['user_1', 'user_2'],
            });

            console.log(subscriptions);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          subscriptions = client.objects.add_subscriptions(
              collection="collection",
              object_id="object_id",
              recipients=["user_1", "user_2"],
          )
          print(subscriptions)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
            "github.com/stainless-sdks/knock-go/shared"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            subscriptions, err := client.Objects.AddSubscriptions(
              context.TODO(),
              "collection",
              "object_id",
              knock.ObjectAddSubscriptionsParams{
                Recipients: knock.F([]knock.RecipientRequestUnionParam{shared.UnionString("user_1"), shared.UnionString("user_2")}),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", subscriptions)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.objects.ObjectAddSubscriptionsParams;
          import app.knock.api.models.recipients.subscriptions.Subscription;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  ObjectAddSubscriptionsParams params = ObjectAddSubscriptionsParams.builder()
                      .collection("collection")
                      .objectId("object_id")
                      .addRecipient("user_1")
                      .addRecipient("user_2")
                      .build();
                  List<Subscription> subscriptions = client.objects().addSubscriptions(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          subscriptions = knock.objects.add_subscriptions("collection", "object_id", recipients: ["user_1",
          "user_2"])


          puts(subscriptions)
  /v1/messages/batch/interacted:
    post:
      callbacks: {}
      description: Marks the given messages as interacted with.
      operationId: batchMarkMessagesAsInteracted
      parameters: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BatchMessagesInteractedRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                description: The list of messages that were updated
                example:
                  - actors:
                      - user_123
                    archived_at: null
                    channel_id: 123e4567-e89b-12d3-a456-426614174000
                    clicked_at: null
                    data:
                      foo: bar
                    engagement_statuses:
                      - read
                      - seen
                    id: 1jNaXzB2RZX3LY8wVQnfCKyPnv7
                    inserted_at: '2021-01-01T00:00:00Z'
                    interacted_at: null
                    link_clicked_at: null
                    metadata:
                      external_id: 123e4567-e89b-12d3-a456-426614174000
                    read_at: null
                    recipient: user_123
                    scheduled_at: null
                    seen_at: null
                    source:
                      __typename: NotificationSource
                      categories:
                        - collaboration
                      key: comment-created
                      version_id: 123e4567-e89b-12d3-a456-426614174000
                    status: sent
                    tenant: tenant_123
                    updated_at: '2021-01-01T00:00:00Z'
                    workflow: comment-created
                items:
                  $ref: '#/components/schemas/Message'
                title: BatchListMessagesResponse
                type: array
          description: OK
      summary: Mark messages as interacted
      tags:
        - Messages
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const messages = await client.messages.batch.markAsInteracted({
              message_ids: ['1jNaXzB2RZX3LY8wVQnfCKyPnv7'],
            });

            console.log(messages);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          messages = client.messages.batch.mark_as_interacted(
              message_ids=["1jNaXzB2RZX3LY8wVQnfCKyPnv7"],
          )
          print(messages)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            messages, err := client.Messages.Batch.MarkAsInteracted(context.TODO(), knock.MessageBatchMarkAsInteractedParams{
              MessageIDs: knock.F([]string{"1jNaXzB2RZX3LY8wVQnfCKyPnv7"}),
            })
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", messages)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.messages.Message;
          import app.knock.api.models.messages.batch.BatchMarkAsInteractedParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BatchMarkAsInteractedParams params = BatchMarkAsInteractedParams.builder()
                      .addMessageId("1jNaXzB2RZX3LY8wVQnfCKyPnv7")
                      .build();
                  List<Message> messages = client.messages().batch().markAsInteracted(params);
              }
          }
        ruby: |-
          require "knockapi"

          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )

          messages = knock.messages.batch.mark_as_interacted(message_ids: ["1jNaXzB2RZX3LY8wVQnfCKyPnv7"])

          puts(messages)
  /v1/objects/{collection}/bulk/set:
    post:
      callbacks: {}
      description: Bulk sets objects in the specified collection.
      operationId: bulkSetObjects
      parameters:
        - description: The collection this object belongs to.
          in: path
          name: collection
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BulkSetObjectsRequest'
        description: Params
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkOperation'
          description: OK
      summary: Bulk set objects
      tags:
        - Objects
        - Bulk operations
      x-stainless-snippets:
        typescript: |-
          import Knock from '@knocklabs/node';

          const client = new Knock({
            bearerToken: process.env['KNOCK_API_KEY'], // This is the default and can be omitted
          });

          async function main() {
            const bulkOperation = await client.objects.bulk.set('collection', {
              objects: [{ id: 'project_1', collection: 'projects' }],
            });

            console.log(bulkOperation.id);
          }

          main();
        python: |-
          import os
          from knockapi import Knock

          client = Knock(
              bearer_token=os.environ.get("KNOCK_API_KEY"),  # This is the default and can be omitted
          )
          bulk_operation = client.objects.bulk.set(
              collection="collection",
              objects=[{
                  "id": "project_1",
                  "collection": "projects",
              }],
          )
          print(bulk_operation.id)
        go: |
          package main

          import (
            "context"
            "fmt"

            "github.com/stainless-sdks/knock-go"
            "github.com/stainless-sdks/knock-go/option"
          )

          func main() {
            client := knock.NewClient(
              option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("KNOCK_API_KEY")
            )
            bulkOperation, err := client.Objects.Bulk.Set(
              context.TODO(),
              "collection",
              knock.ObjectBulkSetParams{
                Objects: knock.F([]knock.InlineObjectRequestParam{knock.InlineObjectRequestParam{
                  ID: knock.F("project_1"),
                  Collection: knock.F("projects"),
                }}),
              },
            )
            if err != nil {
              panic(err.Error())
            }
            fmt.Printf("%+v\n", bulkOperation.ID)
          }
        java: |-
          package app.knock.api.example;

          import app.knock.api.client.KnockClient;
          import app.knock.api.client.okhttp.KnockOkHttpClient;
          import app.knock.api.models.bulkoperations.BulkOperation;
          import app.knock.api.models.objects.InlineObjectRequest;
          import app.knock.api.models.objects.bulk.BulkSetParams;

          public final class Main {
              private Main() {}

              public static void main(String[] args) {
                  // Configures using the `KNOCK_API_KEY` and `KNOCK_BASE_URL` environment variables
                  KnockClient client = KnockOkHttpClient.fromEnv();

                  BulkSetParams params = BulkSetParams.builder()
                      .collection("collection")
                      .addObject(InlineObjectRequest.builder()
                          .id("project_1")
                          .collection("projects")
                          .build())
                      .build();
                  BulkOperation bulkOperation = client.objects().bulk().set(params);
              }
          }
        ruby: >-
          require "knockapi"


          knock = Knockapi::Client.new(
            bearer_token: "My Bearer Token" # defaults to ENV["KNOCK_API_KEY"]
          )


          bulk_operation = knock.objects.bulk.set("collection", objects: [{id: "project_1", collection:
          "projects"}])


          puts(bulk_operation)
security:
  - BearerAuth: []
servers:
  - url: https://api.knock.app
    variables: {}
tags:
  - description: An Audience is a segment of users.
    name: Audiences
  - description: >-
      A bulk operation is a set of changes applied across zero or more records triggered via a call to the
      Knock API and performed asynchronously.
    name: Bulk operations
  - description: >-
      Channel data is data that is specific to a recipient and a channel, like push tokens, or one or more
      Slack connections.
    name: Channel data
  - description: A message sent to a single recipient on a channel.
    name: Messages
  - description: An object represents a resource in your system that you want to map into Knock.
    name: Objects
  - description: >-
      Preferences are a way to configure how notifications are sent to recipients. They are a set of
      configuration that determines whether a recipient should receive a notification for a given workflow on
      a specific channel.
    name: Preferences
  - description: A provider represents a third-party service that Knock integrates with and is configured via a channel.
    name: Providers
  - description: A schedule is a per-recipient, timezone-aware configuration for when to invoke a workflow.
    name: Schedules
  - description: A subscription represents a connection between a recipient and an object, used to represent a list.
    name: Subscriptions
  - description: >-
      A tenant represents a top-level entity from your system, like a company, organization, account, or
      workspace.
    name: Tenants
  - description: >-
      A user is an individual from your system, represented in Knock. They are most commonly a recipient of a
      notification.
    name: Users
  - description: Operations for triggering and canceling workflow executions.
    name: Workflow Triggers
  - description: A workflow is a structured set of steps that is triggered to produce notifications sent over channels.
    name: Workflows