---
title: Triggering workflows
---

import Callout from "../../components/Callout";

Workflows that you design within Knock are triggered from within your codebase by calling the `notify` endpoint and telling Knock _who_ should be a potential recipient.

<Callout
  emoji="ðŸŒ "
  text={
    <>
      <span className="font-bold">Knock terminology clarification.</span> Throughout our documentation you'll see us refer to notify calls and workflow triggers. These terms are synonymous. 
      <br/>
      <br/>
      If you use our SDKs, you'll be using <code>.notify()</code> which calls the workflow trigger endpoint you'll find in <a href="/reference#trigger-workflow">our API reference</a>.
    </>
  }
/>

It's important to realize that calling `notify` in Knock may result in no messages being sent to your users. This is because calling `notify` will trigger a workflow, but your end users may have indicated through their `preferences` that they don't wish to be notified by workflows of that type. The good news is that Knock handles all preference-based opt-outs for you automatically.

## Triggering workflows

Workflows are triggered via a call to the `notify` endpoint, which tells Knock to run a specified payload of `recipients` and `data` through the workflow specified by the call.

```js Trigger a Knock workflow
const { Knock } = require("@knocklabs/node");
const knock = new Knock(process.env.KNOCK_API_KEY);

await knock.notify("new-user-invited", {
  // The list of recipients
  recipients: ["user_1", "user_2"],
  // Data to be passed to the template
  data: {
    invitee_name: "Jane Doe",
    invitee_email: "jane.doe@example.com",
    invitee_role: "member",
  },
});
```

Learn more about triggering workflows in [our API reference](/reference#workflows).

### Schema

| Property         | Type                  | Description                                                                                                 |
| ---------------- | --------------------- | ----------------------------------------------------------------------------------------------------------- |
| key\*            | string                | The human readable key of the workflow from the Knock dashboard                                             |
| actor            | RecipientIdentifier   | An identifier of who or what performed this action (optional)                                               |
| recipients\*     | RecipientIdentifier[] | A list of user ids, or object references of who to notify for this workflow                                 |
| data             | map                   | A map of properties that are required in the templates in this workflow                                     |
| cancellation_key | string                | A unique identifier to reference the workflow when canceling                                                |
| tenant           | string                | An optional identifier of the owning tenant object for the notifications generated during this workflow run |

### Recipient identifiers

When you want to identify a recipient in a workflow, either as an actor or as a recipient you can send either:

- A string indicating a user that you have previously identified to Knock (e.g. `user-1`).
- A reference of an object that you have previously set within Knock (e.g. `{ id: "project-1", collection: "projects" }`).

### Response

Triggering a workflow will always return a unique UUID v4 representing the workflow run.

```json Trigger workflow response
{
  "workflow_run_id": "05f8a70d-e42a-46dc-86fa-aada5752f6cf"
}
```

## Attributing the action to a user or object

Knock supports passing an `actor` in your workflow trigger calls, which allows you to attribute the workflow trigger to an individual recipient (user or object).

```js Triggering a Knock workflow with an actor
const { Knock } = require("@knocklabs/node");
const knock = new Knock(process.env.KNOCK_API_KEY);

await knock.notify("new-user-invited", {
  actor: "user_0",
  recipients: ["user_1", "user_2"],
  data: {
    invitee_name: "Jane Doe",
  },
});
```

Calling a workflow trigger with an actor will have the following effect:

- The `actor` property will be available within your message templates including the full user or object that performed this action.
- When a workflow being triggered includes a batch step, the actor will be recorded as one actor who performed an action in the batch, which you can access via the `actors` key in your template.
- Any workflows that contain an in-app feed channel step will produce a message that links the actor, and the actor will be loaded in any requests to this feed.

## Passing data

You can also pass the schema data required by the workflow into the `notify` call. The
payload must be a valid JSON object, with nested objects and arrays supported.

The data requirements for the payload are determined in the workflow builder, including
indicating which keys are required.

<!-- ## Preventing duplicates

No one likes duplicate notifications.

To guard against sending duplicates you can implement idempotency into your notify calls such that subsequent
calls with the same `idempotencyKey` will fail if any of the previous calls have succeeded. We
recommend using an idempotency key with enough entropy, like a uuid v4.

We'll keep idempotency keys in our system for at least 7 days before they are purged.

```js
const { Knock } = require("@knocklabs/node");
const uuid = require("uuid4");
const knock = new Knock(process.env.KNOCK_API_KEY);

const idempotencyKey = uuid();

await knock.notify("new-user-invited", {
  actor: "user_3",
  recipients: ["user_1", "user_2"],
  data: {
    invitee_name: "Jane Doe",
    invitee_email: "jane.doe@example.com",
    invitee_role: "member",
  },
  idempotencyKey,
});
``` -->

## Generating a cancellation key

Each `notify` call can optionally include a `cancellation_key` that allows you to uniquely identify
it when canceling. Providing your own cancellation key means that you don't need to keep track of
the Knock internal identifiers generated when calling `notify`.

You can read more about canceling workflows [in our guide](/send-notifications/canceling-workflows).

**Keep the following in mind when generating a cancellation key:**

1. Provide a value that allows you to uniquely identify the notify run for the batch of recipients.
   A good example in an invite notification is the `id` of a user invite so that we can easily stop reminders
   for that invite once a user has accepted it.

2. The cancellation key represents the workflow _run_, not the notifications generated per recipient, so
   you usually don't need to include a recipient identifier within the `cancellation_key`.

3. The cancellation key is _scoped per workflow_ so you don't need to include the workflow key
   in the cancellation key.

## Multi-tenancy in notifications

You can optionally pass a `tenant` to your `notify` call. If you are a product that allows users to belong to multiple tenants,
you'll want to pass a `tenant` to Knock in your notify calls so that you can make sure a given user's in-app feed is scoped to the
tenants to which they belong in your product.

You can read more about [supporting multi-tenancy in our guide](/send-and-manage-data/multi-tenancy).

## Triggering workflows with objects

For cases when you want to notify an [object](/send-and-manage-data/objects) in your system (either because it has its own in-app feed or because it's connected to a Slack channel), you'll include those objects in the `recipients` key of your workflow trigger.

An object reference always comes in the form of a dictionary with `id` and `collection` properties.

```javascript Workflow trigger with an object as a recipient
await knock.workflows.trigger("new-comment", {
  recipients: [...projectUserIds, { id: project.id, collection: "projects" }],
  data: { comment },
});
```

Remember, an object can also be an `actor` of a workflow as well!

```javascript Workflow trigger with an object as an actor
await knock.workflows.trigger("new-comment", {
  actor: { id: project.id, collection: "projects" },
  recipients: projectUserIds,
  data: { comment },
});
```
