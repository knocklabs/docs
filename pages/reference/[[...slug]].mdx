---
title: API reference
showNav: false
layout: api
---

import { Attributes, Attribute } from "../../components/Attributes";
import { Endpoints, Endpoint } from "../../components/Endpoints";

The Knock API enables you to add a complete notification engine to your product. This API provides
programmatic access to integrating Knock via a REST-ful API.

The API base URL for all requests is:

```
https://api.knock.app/v1
```

## Client libraries

Knock offers native SDKs in several popular programming languages:

- [Node JS](https://github.com/knocklabs/knock-node)
- [Python](https://github.com/knocklabs/knock-python)
- [Elixir](https://github.com/knocklabs/knock-elixir)

## API keys

Knock authenticates your API requests using your account's API keys. API requests made without authentication or using an incorrect key will return a 401 error. Requests using a valid key but with insufficient permissions will return a 403 error.

You can view and manage your API keys in the Developer Dashboard. There are two types of API keys:

- Publishable keys are only meant to identify your account with Knock. They aren't secret, and can safely be made public in any of your client-side code. Publishable keys are prepended with `pk_*`.

- Secret keys can perform any API request to Knock, they should be kept secure and private! Be sure to prevent secret keys from being made publicly accessible, such as in client-side code, GitHub, unsecured S3 buckets, and so forth. Secret keys are prepended with `sk_*`.

Each Environment in your account has both a publishable and secret key pair. API requests will be scoped to the provided key's Environment.

## Authentication

You must pass your API key to Knock as a Bearer token using the following header:

```
Authentication: Bearer sk_test_12345
```

## Errors

Knock uses standard [HTTP response codes](https://developer.mozilla.org/en-US/Web/HTTP/Status) to indicate the success or failure of your API requests.

- `2xx` - Indicates success.
- `4xx` - Indicates an error, normally due to error caused by incorrect or missing request information (e.g. providing an incorrect API key).
- `5xx` - Indicates a Knock server error.

## Users

A user represents an individual who may need to receive a notification from Knock. They are always referenced by your internal identifier.

### Attributes

<Attributes>
  <Attribute
    name="id"
    type="string"
    description="Unique identifier for the user"
  />
  <Attribute name="name" type="string" description="The fullname of the user" />
  <Attribute name="email" type="string" description="The email of the user" />
  <Attribute
    name="*"
    type="key-value pairs"
    description="Any custom properties"
  />
</Attributes>

<Endpoints>
  <Endpoint name="identify-user" method="PUT" path="/users/:user_id" />
  <Endpoint name="get-user" method="GET" path="/users/:user_id" />
</Endpoints>

### Example response

```json
{
  "__typename": "User",
  "id": "user_1",
  "name": "User name",
  "email": "user@example.com",
  "foo": "bar",
  "baz": true,
  "created_at": null,
  "updated_at": "2021-03-05T12:00:00Z"
}
```

## Identify a user

Identifying a user will create or update a user in Knock, merging the properties given with what we currently have set on the user (if any).

### Endpoint

<Endpoint method="PUT" path="/users/:user_id" />

### Path parameters

<Attributes>
  <Attribute
    name="id"
    type="string"
    description="Unique identifier of the user"
  />
</Attributes>

### Body parameters

<Attributes>
  <Attribute name="name" type="string" description="The name of the user" />
  <Attribute name="email" type="string" description="The email of the user" />
  <Attribute
    name="*"
    type="key-value pairs"
    description="Any custom properties"
  />
</Attributes>

### Returns

A user.

## Get a user

Retrieve a user by their ID, including all properties previously set.

### Endpoint

<Endpoint method="GET" path="/users/:user_id" />

### Path parameters

<Attributes>
  <Attribute
    name="id"
    type="string"
    description="Unique identifier of the user"
  />
</Attributes>

### Returns

A user.

## Notify

A notify calls a workflow created via the Knock dashboard.

### Endpoint

<Endpoint method="POST" path="/notify" />

### Body parameters

<Attributes>
  <Attribute
    name="name"
    type="string"
    description="The key of the workflow to call"
  />
  <Attribute
    name="recipients"
    type="string[]"
    description="A list of user ids of who should be notified"
  />
  <Attribute
    name="actor"
    type="string"
    description="The id of the actor who performed the action associated"
  />
  <Attribute
    name="cancellation_key"
    type="string"
    description="The key to use for canceling the workflow"
  />
  <Attribute
    name="data"
    type="dictionary"
    description="A set of key value pairs to pass to the notify"
  />
</Attributes>

### Returns

```json
{
  "result_id": "some-result-id"
}
```

## Canceling workflows

Cancel a delayed workflow for one or more recipients.

### Endpoint

<Endpoint method="POST" path="/notify/cancel" />

### Body parameters

<Attributes>
  <Attribute
    name="name"
    type="string"
    description="The key of the workflow to call"
  />
  <Attribute
    name="cancellation_key"
    type="string"
    description="The cancellation key unique to the notify"
  />
  <Attribute
    name="recipients"
    type="string[]"
    description="An optional list of user ids to cancel the notify for"
  />
</Attributes>

### Returns

`204`, with empty content.

## Feeds

A feed exposes the messages delivered to an in-app feed channel, formatted specially to be consumed
in a notification feed.

A feed will always return a list of `FeedItems`, which are pointers to a message delivered and contain
all of the information needed in order to render an item within a notification feed.

**Note: feeds are a specialized form of messages that are designed purely for in-app rendering, and
as such return information that is required on the client to do so**

<Endpoints>
  <Endpoint method="GET" path="/users/:user_id/feeds/:feed_id" />
</Endpoints>

### Attributes

<Attributes>
  <Attribute
    name="entries"
    type="FeedItem[]"
    description="An ordered list of feed items (most recent first)"
  />
  <Attribute
    name="page_info"
    type="PageInfo"
    description="Pagination information for the items returned"
  />
  <Attribute
    name="vars"
    type="object"
    description="Environment specific account variables"
  />
  <Attribute
    name="meta"
    type="FeedMetadata"
    description="Information about the total unread and unseen items"
  />
</Attributes>

### Example response

```json
{
  "entries": [
    {
      "__typename": "FeedItem",
      "__cursor": "g3QAAAABZAACaWRtAAAAGzFzTXRJc1J2WnRZZjg2YU9ma00yUENwQzZYYw==",
      "activities": [
        {
          "__typename": "Activity",
          "actor": {
            "__typename": "User",
            "id": "c121a5ea-8f2c-4c60-ab40-9966047d5bea",
            "created_at": null,
            "updated_at": "2021-05-08T20:40:01.340Z",
            "email": "some-user@knock.app",
            "name": "Some User"
          },
          "data": {
            "dest_environment_name": "Production",
            "src_environment_name": "Development",
            "total_merged": 1
          },
          "id": "1sMtIwNnDIV52a8G8kmymzDVExQ",
          "inserted_at": "2021-05-11T00:50:09.895759Z",
          "recipient": {
            "__typename": "User",
            "id": "c121a5ea-8f2c-4c60-ab40-9966047d5bea",
            "created_at": null,
            "updated_at": "2021-05-08T20:40:01.340Z",
            "email": "some-user@knock.app",
            "name": "Some User"
          },
          "updated_at": "2021-05-11T00:50:09.895759Z"
        }
      ],
      "actors": [
        {
          "__typename": "User",
          "id": "c121a5ea-8f2c-4c60-ab40-9966047d5bea",
          "created_at": null,
          "updated_at": "2021-05-08T20:40:01.340Z",
          "email": "some-user@knock.app",
          "name": "Some User"
        }
      ],
      "archived_at": null,
      "blocks": [
        {
          "content": "**{{ actor.name }}** merged {{ total_merged }} {% if total_merged == 1 %} change {% else %} changes {% endif %}\nfrom **{{ src_environment_name }}** into **{{ dest_environment_name }}**.",
          "name": "body",
          "rendered": "<p><strong>The person</strong> merged 1  change \nfrom <strong>Development</strong> into <strong>Production</strong>.</p>",
          "type": "markdown"
        },
        {
          "content": "{{ vars.app_url }}/{{ account_slug }}/commits",
          "name": "action_url",
          "rendered": "https://example.com/thing/commits",
          "type": "text"
        }
      ],
      "data": {
        "dest_environment_name": "Production",
        "src_environment_name": "Development",
        "total_merged": 1
      },
      "id": "1sMtIsRvZtYf86aOfkM2PCpC6Xc",
      "inserted_at": "2021-05-11T00:50:09.904531Z",
      "read_at": "2021-05-13T02:45:28.559124Z",
      "seen_at": "2021-05-11T00:51:43.617550Z",
      "source": {
        "__typename": "WorkflowSource",
        "key": "merged-changes",
        "version_id": "7251cd3f-0028-4d1a-9466-ee79522ba3de"
      },
      "total_activities": 1,
      "total_actors": 1,
      "updated_at": "2021-05-13T02:45:28.559863Z"
    }
  ],
  "vars": {
    "app_name": "The app name"
  },
  "meta": {
    "__typename": "FeedMetadata",
    "unread_count": 0,
    "unseen_count": 0
  },
  "page_info": {
    "__typename": "PageInfo",
    "after": null,
    "before": null,
    "page_size": 50
  }
}
```

## Get a feed

Retreieves a feed of items for a given `user_id` on the given `feed_id`.

**Note: if you're making this call from a clientside environment you should using the publishable key
along with a user token to make this request**

### Endpoint

<Endpoint method="GET" path="/users/:user_id/feeds/:feed_id" />

### Path parameters

<Attributes>
  <Attribute name="user_id" type="string" description="The ID of the user" />
  <Attribute
    name="feed_id"
    type="string"
    description="The ID of the feed (the channel ID)"
  />
</Attributes>

### Query parameters

<Attributes>
  <Attribute
    name="page_size"
    type="number"
    description="The total number to retrieve per page (defaults to 50)"
  />
  <Attribute
    name="after"
    type="string"
    description="The cursor to retrieve items after (hint: use the `__cursor` field)"
  />
  <Attribute
    name="before"
    type="string"
    description="The cursor to retrieve items before (hint: use the `__cursor` field)"
  />
  <Attribute
    name="source"
    type="string (optional)"
    description="Limits the feed to only items of the source workflow"
  />
  <Attribute
    name="status"
    type="string (optional)"
    description="One of `unread`, `unseen`, `all`"
  />
</Attributes>

### Returns

A feed response.

## Messages

A message is a notification delivered on a particular channel to a user.

<Endpoints>
  <Endpoint name="notify" method="PUT" path="/messages/:id/:status" />
  <Endpoint name="notify" method="DELETE" path="/messages/:id/:status" />
  <Endpoint name="notify" method="POST" path="/messages/batch/:status" />
</Endpoints>

### Attributes

<Attributes>
  <Attribute
    name="id"
    type="string"
    description="The unique ID of this message"
  />
  <Attribute
    name="channel_id"
    type="string"
    description="The ID of the channel for where this message was delivered"
  />
  <Attribute
    name="recipient_id"
    type="string"
    description="The ID of the user who received the message"
  />
  <Attribute
    name="workflow"
    type="string"
    description="The key of the workflow that this message was generated from"
  />
  <Attribute
    name="status"
    type="string"
    description="One of `queued`, `sent`, `delivered`, `undelivered`, `seen`, `unseen`"
  />
  <Attribute
    name="read_at"
    type="string (optional)"
    description="When the message was last read"
  />
  <Attribute
    name="seen_at"
    type="string (optional)"
    description="When the message was last seen"
  />
  <Attribute
    name="archived_at"
    type="string (optional)"
    description="When the message was archived"
  />
</Attributes>

### Example response

```json
{
  "__typename": "Message",
  "id": "1rjI9XBgWQ6EUA3D3Ul3VjUimOD",
  "channel_id": "0bfd9f86-56b0-41f0-ade3-dc5cc6a69bb8",
  "recipient_id": "user_12345",
  "workflow": "new-comment",
  "status": "delivered",
  "read_at": null,
  "seen_at": null,
  "archived_at": null,
  "inserted_at": "2021-03-05T12:00:00Z",
  "updated_at": "2021-03-05T12:00:00Z"
}
```

## Updating a message status

Marks the given message as the `status`, recording an event in the process.

### Endpoint

<Endpoint method="PUT" path="/messages/:id/:status" />

### Path parameters

<Attributes>
  <Attribute name="id" type="string" description="The ID of the message" />
  <Attribute
    name="status"
    type="enum"
    description="One of `seen`, `read`, `archive`"
  />
</Attributes>

### Returns

A Message.

## Undoing a message status change

Unmarks the given message as the `status`, recording an event in the process.

### Endpoint

<Endpoint method="DELETE" path="/messages/:id/:status" />

### Path parameters

<Attributes>
  <Attribute name="id" type="string" description="The ID of the message" />
  <Attribute
    name="status"
    type="enum"
    description="One of `seen`, `read`, `archived`"
  />
</Attributes>

### Returns

A Message.

## Batch changing message statuses

Messages changes can also be made in bulk by using the batch API, where all message ids given in
the list will have their statuses changed.

### Endpoint

<Endpoint method="POST" path="/messages/batch/:status" />

### Path parameters

<Attributes>
  <Attribute
    name="status"
    type="enum"
    description="One of `seen`, `read`, `archived` or `unseen`, `unread`, `unarchived`"
  />
</Attributes>

### Body parameters

<Attributes>
  <Attribute
    name="message_ids"
    type="string[]"
    description="A list of one or more message IDs"
  />
</Attributes>

### Returns

A list of messages that were mutated during the call.

<!-- ## Lists

A list represents a collection of users. It’s used to easily send notifications to many related individuals at once.

You may want to consider using lists when you have a collection of users that is unbounded in size who may need to be notified when an event occurs (like followers, or members of a project).

Lists can be referenced when triggering workflows so that you don't need to send specific user ids with your events. Structured data can also be captured for each user on a list.

**List names**

The list name is used as an identifier for the list, because of this you will need to ensure that the list name is unique and contains alphanumeric characters and `.`, `-`, and `_` only.

### Creating a list

To create a list you just need to use a unique identifier for the list name. If the list with the given identifier already exists, the create endpoint will return an error.

**Endpoint**

`POST https://api.knock.app/v1/lists`

**Payload**

```json
{
  // Name is a required field and must be unique
  "name": "project.project_123.followers",
  // Optionally you can create the list with users specified as well
  "users": [],
  // Optionally you can provide any structured data to be stored on the list
  "properties": {
    "foo": "bar"
  }
}
```

### Adding users to a list

You can append new users to a list, including any metadata that needs to be kept on the user within the list. If the user already exists on the list, the metadata will be merged.

**Endpoint**

`POST https://api.knock.app/v1/lists/:name/users`

**Payload**

```json
{
  "users": [
    {
      // id is a required field per user
      "id": "user_1",
      // Optionally you can provide structured data to be stored
      "properties": {
        "role": "admin"
      }
    }
  ]
}
```

### Removing users from a list

Will attempt to remove the given users from the list.

**Endpoint**

`DELETE https://api.knock.app/v1/lists/:name/users`

**Payload**

```json
{
  // Accepts user ids, or a user object (with an id)
  "users": ["user_1"]
}
```

### Get a list

Will retrieve a list, including users associated. Users returned will be a `PaginatedResult` returned in ascending order of when the user was added to the list.

**Endpoint**

`GET https://api.knock.app/v1/lists/:name`

**Response**

```json
{
  "__typename": "list",
  "name": "project.project_123.followers",
  "users": {
    "data": [
      {
        "__typename": "list_member",
        "user_id": "user_1",
        "user": {
          "__typename": "user",
          "id": "user_1",
          "properties": {
            "name": "User name",
            "email": "user@example.com",
            "foo": "bar",
            "baz": true
          },
          "preferences": null,
          "updated_at": "2021-03-05T12:00:00Z"
        },
        "properties": {
          "role": "admin"
        },
        "updated_at": "2021-03-05T12:00:00Z"
      }
    ],
    "page_info": {
      "has_next_page": false,
      "has_previous_page": false,
      "per_page": 25,
      "total_pages": 1,
      "total_items": 1
    }
  },
  "properties": {
    "foo": "bar"
  }
}
```

### Deleting a list

Removes the list and all users associated with the list.

**Endpoint**

`DELETE https://api.knock.app/v1/lists/:list_name`

## Events

An event is used as a potential trigger for a workflow. It represents an action happening in your product that a user may have taken.

**Naming events**

Event names should clearly label what happened. Best practices for event naming can be found in the Segment guide, which typically follows a Noun Verb approach, like `User Created`.

**Event Properties**

Properties of an event are _important values_ – they are unstructured data that contain the attributes you will use to template your notifications. For that reason we suggest that you send a broad range of properties with your event data — great examples are things like object ids, names, and other attributes.

### Registering an event with Knock

**Endpoint**

`POST https://api.knock.app/v1/events`

**Payload**

```json
{
  "name": "Comment Created",
  // The user who performed the action
  "user_id": "user_1",
  "properties": {
    "workspace_id": "workspace_1",
    "document_id": "document_1",
    "document_name": "The Soul of a New Machine",
    "comment_id": "comment_1",
    "comment_text": "I LOVE this part of the book"
  },
  // If the timestamp is omitted a value will be set once received
  "timestamp": "2021-03-05T12:00:00.000Z"
}
```

### Idempotent events

It is **strongly recommended** that you specify an idempotency key when sending your events. This is useful in ensuring that duplicate events are not processed. Knock will guarantee to never process an event twice, unless explicitly instructed to do so.

```json
{
  "name": "Comment Created",
  // Here we're building an idempotency key from the document id
  // and the comment id
  "idempotency_key": "document_1:comment_1:created",
  "user_id": "user_1",
  "properties": {
    // Omitted for brevity
  },
  "timestamp": "2021-03-05T12:00:00.000Z"
}
```

### Specifying individual recipients

Individual recipients can always be specified on the event, where necessary. We encourage this approach for when the number of recipients is small, like in the case of comment threads where the extra bookkeeping for list creation may be unnecessary.

```json
{
  "name": "Comment Created",
  "user_id": "user_1",
  "properties": {
    // Omitted for brevity
  },
  "recipients": ["user_2", "user_3"]
}
```

### Sending to one or more lists

To send to one or more lists of recipients, you can user the `recipient_lists` property on the event as follows:

```json
{
  "name": "Comment Created",
  "user_id": "user_1",
  "properties": {
    // Omitted for brevity
  },
  "recipient_lists": ["project.project_123.followers"]
}
```

### Workflow-defined recipients

Alternatively, you can omit the recipients properties all together and select recipients when you are building your workflows in the Knock dashboard. This approach has the nice side effect of decoupling your event code from your notifications code.

### Batch sending events

Knock is designed to ingest a high volume of events from your service. For this reason it may be preferable to bulk send events to Knock to reduce the HTTP overhead per request.

Knock can receive up to **100 events** per batch request. If a higher number is specified, then the request may be rejected with a 422 response.

**Endpoint**

`POST https://api.knock.app/v1/batch/events`

**Payload**

```json
{
  "batch": [
    {
      "name": "Comment Created",
      "user_id": "user_1",
      "properties": {
        // Omitted for brevity
      }
    },
    {
      "name": "Project Created",
      "user_id": "user_2",
      "properties": {
        // Omitted for brevity
      }
    }
  ]
}
```

## Activities

An activity represents a change that a user may need to be notified of.

### Activity bundles

Activities within Knock are always presented as a 'bundle' which we use internally to perform grouping and batching of activities. We present a standardized interface to all activities as a bundle to reduce complexity when consuming the API; this means that you may receive a bundle of a single activity.

An activity bundle may be updated _after being created_ (e.g. when a new activity is bundled into it) \*\*where as individual activities are immutable logs of changes.

### Fetch activities for a user

Returns a paginated list of bundled activities, supplied in a descending order of when the activity was generated. Will also return the stats on the number of unread / read activities for the user.

**Endpoint**

`GET https://api.knock.app/v1/users/:user_id/activities`

**Response**

```json
{
  "activity_bundles": {
    "data": [
      {
        "__typename": "activity_bundle",
        "id": "activity_bundle_12345",
        "activities": [
          {
            "__typename": "activity",
            "id": "activity_12345"
          }
        ],
        "read_at": null,
        "seen_at": null
      }
    ],
    "page_info": {
      "has_next_page": false,
      "has_previous_page": false,
      "per_page": 25,
      "total_pages": 1,
      "total_items": 1
    }
  },
  "stats": {
    "total_unread": 1,
    "total_read": 0,
    "total_unseen": 1,
    "total_seen": 0
  }
}
```

### Mark as read

Marks the activity as read for the user, recording an engagement event in the process.

**Endpoint**

`PUT https://api.knock.app/v1/activities/:id/read`

**Response**

### Mark as seen

## Secured user keys

When working with client-side features to communicate directly with the Knock API you must generate user specific keys that will be used in place of your Knock secret key. This ensures that users can only ever access their content without you needing to proxy calls via your backend.

### Creating a new key

To generate a new secured key you only need to supply the user id as a required scoping field. You should generate this key within your backend, and expose the result to the client-side application.

**Endpoint**

`POST https://api.knock.app/v1/secured_keys`

**Payload**

```json
{
  // The user id is required
  "user_id": "user_1",
  // Optionally you can limit to particular channels that are allowed
  // to be queried with this key
  "channel_ids": []
}
```

**Response**

```json
{
  "status": "ok",
  "expires_at": "2021-03-07T12:00:00.000Z",
  "key": "sk_1234567890abcdefghijklmnopqrst"
}
```

### Using a secured key

You can use a secured key in the following endpoints:

- Fetching all notifications for a user, channel pair
- Marking activities for a user as read or seen

## Preferences

Preferences exist on a users profile and determine whether or not they should receive certain types on notifications.

## Notifications

## Engagement

Engagement data is all of the user interactions with notifications (clicks, opens, delivers etc). -->
