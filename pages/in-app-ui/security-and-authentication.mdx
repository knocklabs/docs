---
title: Security & authentication
description: Learn more about how to secure your client-side applications as they integrate with Knock.
section: Building in-app UI
tags: ["jwt", "signing keys", "missing_user_token", "user token", "enhanced security mode"]
---

import Callout from "../../components/Callout";

<Callout
  emoji="ðŸ‘‰"
  text={
    <>
    <span className="font-bold">Note:</span> This integration guide references examples from our <a href="https://github.com/knocklabs/knock-client-js">client-side JS SDK</a>.
    You only need to add the authentication outlined in this guide if you're integrating
    Knock on the client-side of your applications to use the Knock in-app feed
    or the Knock preferences model.
    </>
  }
/>

Knock's API endpoints enforce security in two ways:

1. By default, all API endpoints require a valid secret API key.
2. A subset of API endpoints can be made with just a public API key, with a signed user token for complete security

Production environments should enable enhanced security mode, which enforces the use of a signed user token.

Environments which do not use enhanced security mode are convenient for development and testing, but are
vulnerable to malicious actors, who may be able to access other users' data. Enhanced security mode
trades convenience for security, and we recommend that you enable it [When going to production](/getting-started/going-to-production).

## API endpoints that can be called with a public API key

The following calls require authentication (when called from the client):

- Fetching a user's notification feed
- Marking a feed message as read, seen, or archived
- Getting or setting a user's preferences

## Authentication (without enhanced security)

In a non-production Knock environment, you can use your public key to authenticate
all users. You do not need to implement any other security mechanisms. Knock will
not reject requests that do not include a signed user token.

**ðŸš¨ This approach is convenient for development and testing, but should not be used
in a production environment with real user data.**

**Client SDK example**

```js
import Knock from "@knocklabs/client";

const knockClient = new Knock(process.env.KNOCK_PUBLIC_API_KEY);

// Tell Knock to use the users id
knockClient.authenticate(currentUser.id);
```

**React notification feed example**

```jsx
<KnockFeedProvider
  // Rest omitted for brevity
  apiKey={process.env.KNOCK_PUBLIC_API_KEY}
  userId={currentUser.id}
>
```

## Authentication (with enhanced security)

When enhanced security mode is enabled, Knock will reject requests that do not include a signed user token.
This token is generated by your backend application, and is used to authenticate a user's requests to Knock.

Using our JWT-based authentication approach means using a shared secret to sign a new JWT on your
backend. This means you can generate the authentication token out-of-band without an additional network request.

### 1. Generate the signing key

You can find the signing key in the Knock dashboard under the "Developers > API keys" page. Save the private
key shown to you here. Note: you won't be shown this key again, so you'll need to regenerate
it if you lose access.

The Knock dashboard will present the generated private key in two formats:

1. Base-64 encoded PEM format, which fits on a single line (convenient for setting environment variables)
2. PEM encoded format, which may be required by certain libraries or platforms (visible under the "Advanced" disclosure)

By convention, we recommend storing the private key in the environment variable `KNOCK_SIGNING_KEY`. This is where the
Knock SDK will look for the key by default.

### 2. Sign the JWT

Within your backend application, you'll need to sign the JWT and make it available to your front-end
client. Usually, you'll do this by passing it down as a serialized property on the user, or passing in a cookie.

At a minimum the JWT to be signed must have:

```json
{
  // The user that you're signing the token for
  "sub": "user_id",
  // When the token was issued
  "iat": 1608600116,
  // Expiry timestamp
  "exp": 1608603716
}
```

To sign your JWT as middleware in a NodeJS express like app:

```js
import Knock from "@knocklabs/client";

app.use((req, res, next) => {
  if (!req.user) {
    return next();
  }

  // Assuming you have set KNOCK_SIGNING_KEY in your environment
  
  res.locals({
    // `signUserToken` can take a second argument to set the expiry of the token
    // and/or specify the signing key to use
    knockToken: Knock.signUserToken(req.user.id),
  });

  next();
});
```

### 3. Send the JWT to the client

In your client application you can now use the JWT to authenticate with Knock:

**Client SDK example**

```js
import Knock from "@knocklabs/client";

const knockClient = new Knock(process.env.KNOCK_PUBLIC_API_KEY);

// Tell Knock to use the users id and the token for the user
knockClient.authenticate(currentUser.id, currentUser.knockToken);
```

**React notification feed example**

```jsx
<KnockFeedProvider
  // Rest of props omitted for brevity
  apiKey={process.env.KNOCK_PUBLIC_API_KEY}
  userId={currentUser.id}
  userToken={currentUser.knockUserToken}
>
```

## Avoiding authentication

You can avoid authentication altogether by proxying requests to Knock via your backend,
although we don't recommend this approach as it will add more latency for your users.

## Troubleshooting

### Errors using your Knock signing key

If you are getting errors like `secretOrPrivateKey must be an asymmetric key when using RS256`,
try using the base-64 encoded format of your signing key generated in the Knock Dashboard (under Developers > API keys > Application Signing Keys).
      
```bash
// .env.local
KNOCK_SIGNING_KEY="LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQoK..."
```
