---
title: Identifying recipients
description: Learn more about how to identify your user and object recipients to power your notifications.
tags:
  [
    "recipients",
    "inline identify",
    "identify",
    "bulk identify",
    "import users",
    "create users",
    "users",
    "objects"
  ]
section: Managing recipients
---

To send notifications to a recipient or reference them as an actor in a notification, their data must be stored in Knock. This process is called **identifying** and works across user and object recipients.

There are three ways to identify recipients:

- **Direct identification**. Make a single server-side API request (`PUT /v1/users/{user_id}`) to upsert one recipient.
- **Inline identification**. Upsert recipients by including recipient data in other client-side or server-side API requests (e.g., `POST /v1/workflows/{workflow_key}/trigger`).
- **Bulk identification**. Make a single server-side API request (`POST /v1/users/bulk/identify`) to upsert many recipients at once.

<Callout
  emoji="💡"
  title="Note:"
  text={
    <>
      All identification methods in Knock use an upsert approach. This means any
      existing data for a recipient is merged during the upsert operation.
    </>
  }
/>

## Direct identification

Make a server-side `users.identify` request to upsert a single recipient in Knock. This is useful to ensure that user data is updated on an ongoing basis, like reflecting updates a user makes to their profile information inside of your product.

<MultiLangCodeBlock
  snippet="users.identify"
  title="Directly identify a recipient"
/>

[API reference ->](/api-reference/users/update)

## Inline identification

You can also identify recipients during other operations, eliminating the need for separate identification API calls.

When using inline identification, Knock guarantees that recipients are identified before executing any other action. This enables lazy recipient creation within Knock and ensures that your recipients exist within Knock before executing calls that reference them. Inline identification is available both server-side and client-side.

Inline identification [requires a list of user objects](/api-reference/users/schemas/inline_identify_user_request) and each object must include an `id`, but may include other [user properties](/managing-recipients/identifying-recipients#setting-recipient-properties) to be upserted.

<AccordionGroup>
  <Accordion title="Server-side inline identification">
    Server-side, inline identification works with any endpoint that accepts a list of recipients:

    - [Workflow triggers](/api-reference/workflows/trigger)
    - [Schedules](/api-reference/schedules/create)
    - [Bulk schedules](/api-reference/schedules/bulk/create)
    - [Subscriptions](/api-reference/objects/add_subscriptions)
    - [Bulk subscriptions](/api-reference/objects/bulk/add_subscriptions)

    <MultiLangCodeBlock
      snippet="workflows.trigger-with-user-identification"
      title="Trigger a workflow with inline identification"
    />

    [API reference ->](/api-reference/workflows/trigger)

  </Accordion>

  <Accordion title="Client-side inline identification">
    For in-app UI components like [feeds](/in-app-ui/react/feed#rendering-the-component) and [guides](/in-app-ui/guides/render-guides#getting-started), you can inline identify recipients directly from the client side using Knock's React or JavaScript SDKs. This approach is particularly useful when building real-time notification experiences where recipient data is immediately required in your frontend application.

    Client-side identification is handled automatically when you initialize the `KnockProvider` with user data. When mounted, the provider will identify the user in Knock by upserting the provided user information.

    ```jsx title="Client-side identification with KnockProvider in React"
        <KnockProvider
          apiKey={process.env.KNOCK_PUBLIC_API_KEY}
          user={{ id: user.id }}
        >
          <KnockFeedProvider feedId={process.env.KNOCK_FEED_CHANNEL_ID}>
            <>
              <NotificationIconButton
                ref={notifButtonRef}
                onClick={(e) => setIsVisible(!isVisible)}
              />
              <NotificationFeedPopover
                buttonRef={notifButtonRef}
                isVisible={isVisible}
                onClose={() => setIsVisible(false)}
              />
            </>
          </KnockFeedProvider>
        </KnockProvider>
    ```

    <Callout
      emoji="🔒"
      title="Security considerations."
      text={
        <>
          Client-side identification should only be used with your{" "}
          <strong>public API key</strong> and is best suited for use cases where
          you're displaying in-app notifications. For more sensitive operations or
          when you need to set extensive user properties, use server-side
          identification methods.
        </>
      }
    />

  </Accordion>
</AccordionGroup>

## Bulk identification

The `users.bulkIdentify` endpoint enables you to upsert many recipients in a single server-side request. This is ideal for initial data imports or large-scale updates.

<MultiLangCodeBlock
  snippet="users.bulkIdentify"
  title="Bulk identify recipients"
/>

[API reference ->](/api-reference/users/bulk/identify)

## Setting recipient properties

When identifying recipients, you pass a set of properties that are persisted. We recommend using your internal user identifier for the `id` value, which is the only required property. Although additional properties aren't required for identification, some properties such as `email` or `phone_number` are required for certain [channel steps](/designing-workflows/channel-step).

### Reserved properties

Recipients have some reserved property names:

| Property       | Description                                                           |
| -------------- | --------------------------------------------------------------------- |
| `name`         | The name of the recipient.                                            |
| `email`        | A valid email address to deliver email notifications to.              |
| `locale`       | A locale code for the recipient, used for internationalizing content. |
| `phone_number` | An E.164 compliant phone number field used when sending SMS messages. |
| `created_at`   | An ISO-8601 datetime of when the recipient was created.               |

### Custom properties

Recipients also accept any number of custom properties as key-value pairs that you define. Custom properties enable you to reference recipient attributes when sending notifications.

<Callout
  emoji="⚠️"
  title="Recipient custom properties cannot exceed 256 kB in size."
  bgColor="red"
  text={
    <>
      When directly identifying your recipients, an update that would result in
      a total custom properties size exceeding this limit will result in a{" "}
      <code>422</code> response.
    </>
  }
/>

## When to identify

Knock provides a flexible set of APIs for you to manage your user data as you scale with us. Ultimately, it's up to you to decide upon the best approach for how you manage your user data with Knock.

### Initial setup

When getting started with Knock, you'll likely have existing recipients to migrate into Knock:

- **Quick start**. Use [inline identification](#inline-identification) to start calling your workflows without any prerequisite calls to the Knock API.
- **Data import**. Use our [bulk identification](/api-reference/users/bulk/identify) to import all recipient data into Knock first.

### Ongoing updates

After identifying your current recipients in Knock, you'll want to continue to update this data when:

- New recipients sign up for your product.
- Knock-relevant data (e.g., `name` or `email`) about a user changes.

A common approach is making subsequent calls to Knock's user identify API following such events. Many customers do this via a deferred job in their backend systems.

Another option is to offload these updates to your workflow trigger calls via inline identification. If you always send Knock the full set of data for your recipients [via workflow trigger calls](/api-reference/workflows/trigger), you can keep your user data up to date in Knock without any additional handling on your end.

## Frequently asked questions

<AccordionGroup>
  <Accordion title="Why isn't inline identification working?">
    A common mistake when implementing inline identification is accidentally passing a list of user ID strings instead of user objects. Inline identification requires user objects (even if they only contain an `id` property), not ID strings.

    ```json title="Incorrectly passing ID strings"
    {
      "recipients": ["user-123", "user-456"]
    }
    ```

    ```json title="Correctly passing user objects"
    {
      "recipients": [ { "id": "user-123" }, { "id": "user-456" } ]
    }
    ```

  </Accordion>

      <Accordion title="Can I set a user's preferences during identification?">
    Yes, preferences can be set during identification, but it's important to understand the implications. Unlike our preferences endpoints, setting preferences during identification will perform a deep merge of the provided preferences into any existing preferences (just like any other <a href="/concepts/users#storing-user-properties">properties stored on the recipient</a>). Unless you intend to leverage this behavior for a specific use case, we generally recommend updating preferences directly via the preferences endpoints.


To set preferences during identification, provide a dictionary under the `preferences` key with each key representing a preference set ID. Unlike the `setPreferences` [method](/preferences/overview#set-a-users-preferences), setting preferences during identification requires explicitly providing the `default` preference set key when updating default preferences.

    ```json title="Providing preferences during identification"
    {
      "id": "user-123",
      "name": "John Doe",
      "preferences": {
        "default": {
          "channel_types": { "email": true, "sms": false }
        }
      }
    }
    ```

    For workflow triggers with [inline identify](/send-notifications/triggering-workflows/api#identifying-recipients-inline), one or more preference sets (including [per-tenant preferences](/preferences/tenant-preferences)) can be upserted by passing a dictionary of [PreferenceSets](/preferences/overview).

    <MultiLangCodeBlock
      title="Setting preferences during a workflow trigger"
      snippet="workflows.trigger-with-user-preferences"
    />

    [API reference ->](/api-reference/workflows/trigger)

  </Accordion>

  <Accordion title="Can I set channel data during identification?">
    Yes, channel data can be set during identification by passing a dictionary under the `channel_data` key, where each key represents the channel ID and the value contains the channel-specific data.

    ```json title="Setting channel data during identification"
    {
      "id": "user-123",
      "name": "John Doe",
      "channel_data": {
        "some-uuid-for-a-channel": {
          "tokens": ["my-push-token"]
        }
      }
    }
    ```

    This is particularly useful for setting push notification tokens, device information, or other channel-specific configuration data when identifying users.

  </Accordion>
</AccordionGroup>
